---
title: "classic solve"
author: "JS"
date: "12 Apr 2022"
output: github_document
---

```{r setup, include=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Solve
This vignettes demonstrates the concept of SB and the potential and flexibility of the SBoo package. First we initialize an SBcore object named World, including data from the spreatsheat version; see the R script for more detailes.
```{r}
#We need to initialize, by default a molecular substance is selected
source("baseScripts/initTestWorld.R")
```

In normal use, SB calculates a steady state (see the vignette ClassicSolve.Rmd), which might take ages to be estabished. To see more details you can investigate what happens in time, dynamic calculations. For this we use another "solver defining function" SBsolve. This function has parameters for the requested number of time steps, nTIMES, and the last time, tmax [s]. 

```{r}
SBsolve
World$NewSolver("SBsolve", nTIMES = 100, tmax = 356 * 500)
```
Use the emissions from the classic spreatsheet, and Solve
```{r}
emissions <- ClassicExcel$ExcelEmissions("current.settings")
World$Solve(emissions)
```
and get the results in a dataframe-like tible
And plot what and how you like with ggplot

```{r}
toPlot <- World$SolutionAsRelational()
ggplot(data = toPlot[toPlot$Scale == "Regional" & toPlot$SubCompart == "air",],
       aes(x = SBtime, y = Mass)) +
       geom_line()
```