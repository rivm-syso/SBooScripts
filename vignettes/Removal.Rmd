---
title: "Removal processes"
author: "JQ"
date: "2023-08-22"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = FALSE)
knitr::knit_meta()
# knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Removal processes
Here we describe the fate processess that are implemented for removal for a compartment:
- Degradation
- Leaching
- Burial
- Escape from air to stratosphere (k_Escape)

### Preparation

```{r initiate, echo=TRUE, message=FALSE, warning=TRUE}
#we initialize the test environment with the default substance, therefor we remove possible earlier value
rm(substance)
#script to initialize test environment, including faking a future 'library(sboo)'
try(source("baseScripts/initTestWorld.R"))
#calculation of the needed SB variables, first compiling their defining functions

# non variable input data which is calculated (see partioning.Rmd) needs to be available before you can proceed


World$fetchData("C.OHrad.n")
World$fetchData("C.OHrad")
World$fetchData("k0.OHrad")

World$fetchData("Temp")
World$fetchData("Q.10")
World$fetchData("BACTcomp")
World$fetchData("BACTtest")

World$fetchData("kdeg.air")
World$fetchData("kdeg.soil")
# World$fetchData("kdeg.sediment")

World$fetchData("kdeg.water")


# This needs to be calculated first:
World$NewCalcVariable("FRorig")
World$CalcVar("FRorig")
World$NewCalcVariable("FRorig_spw")
World$CalcVar("FRorig_spw")
# World$NewCalcVariable("FRACa")
# World$CalcVar("FRACa")
# World$NewCalcVariable("FRACw")
# World$CalcVar("FRACw")
World$NewCalcVariable("FRACs")
World$CalcVar("FRACs")
# World$fetchData()

# debugonce(fKsw)

KswModelled <- f_Ksw(Kow = World$fetchData("Kow"), 
                    pKa, 
                    CorgStandard = World$fetchData("CorgStandard"), 
                    a = with(World$fetchData("QSARtable"), 
                             a[QSAR.ChemClass == World$fetchData("ChemClass")]), 
                    b = with(World$fetchData("QSARtable"), 
                             b[QSAR.ChemClass == World$fetchData("ChemClass")]), 
                    ChemClass = World$fetchData("ChemClass"),
                    RHOsolid = with(World$fetchData("rhoMatrix"),
                                    rhoMatrix[SubCompart == "othersoil"]),
                    alt_form = F)

Ksw.alt <- f_Ksw(Kow = World$fetchData("Kow"), 
                    pKa = 7, 
                    CorgStandard = World$fetchData("CorgStandard"), 
                    a = with(World$fetchData("QSARtable"), 
                             a[QSAR.ChemClass == World$fetchData("ChemClass")]), 
                    b = with(World$fetchData("QSARtable"), 
                             b[QSAR.ChemClass == World$fetchData("ChemClass")]), 
                    ChemClass = World$fetchData("ChemClass"),
                    RHOsolid = with(World$fetchData("rhoMatrix"),
                                    rhoMatrix[SubCompart == "othersoil"]),
                    alt_form = T, KswModelled)

FromData <- World$fetchData("Globals")
FromData$Ksw <- KswModelled
FromData$Ksw.alt <- Ksw.alt
FromData$RHOsolid <- with(World$fetchData("rhoMatrix"),
                                    rhoMatrix[SubCompart == "othersoil"])
World$UpdateData(FromData, keys = T, TableName = "Globals")

kdeg.sediment <- kdegcalc(Q.10 = World$fetchData("Q.10"), 
                          Ksw = World$fetchData("Ksw"), 
                          Biodeg = "r", 
                          C.OHrad.n = World$fetchData("C.OHrad.n"), 
                          Ea.OHrad = World$fetchData("Ea.OHrad"), 
                          k0.OHrad = World$fetchData("k0.OHrad"),
                          CorgStandard = World$fetchData("CorgStandard"), 
                          RHOsolid = World$fetchData("RHOsolid"),
                          Matrix = "sediment")
FromData <- World$fetchData("Globals")
FromData$kdeg.sediment <- kdeg.sediment
World$UpdateData(FromData, keys = T, TableName = "Globals")

World$NewCalcVariable("Kp")
World$CalcVar("Kp")

World$NewCalcVariable("D")
World$CalcVar("D")
World$NewCalcVariable("KpCOL")
World$CalcVar("KpCOL")

World$NewCalcVariable("Kacompw")
World$CalcVar("Kacompw")
World$NewCalcVariable("Kscompw")
World$CalcVar("Kscompw")

World$NewCalcVariable("FRinw")
World$CalcVar("FRinw")

World$NewCalcVariable("Kaerw")
World$CalcVar("Kaerw")
World$NewCalcVariable("Kaers")
World$CalcVar("Kaers")

World$NewCalcVariable("FRingas")
World$CalcVar("FRingas")

```

### Degradation

For calculating the soil side soil to air MTC the degradation rate of the substance in soil is needed.

-   Q.10 is required for calculating the temperature related conversion of the measured or calrculated kdeg per compartment. Q.10 is added as CONSTANT.

-   The concentration bacteria in the test (BACTtest) and the water compartment (BACTcomp) needs to be given. BACTcomp is added to SpeciesCompartments.csv

- k_Degradation is dependant on input rate constants derived under standard conditions for air, soil, water and sediment. 
For molecular species these are (or can be) corrected for temperature and bacteria concentrations. For particulate species such corrections are not yet available/implemented.
- for particulate this means a change in how data is processed. Now degradation rate constants are given per subcompartment and scale etc. Now this is reduced. to the same input as for molecular!

```{r DEGradation new}
World$FromDataAndTo("k_Degradation")

testClass <- World$NewProcess("k_Degradation")
testClass$execute()


```


The algorithms seem to work, but they are calculated also for particulate species. This is not correct, an exception is needed.

THe following code is taken from processes.Rmd. But this does not seem to work.

### Burial
Burial is the process by which chemicals are buried in sediment, e.g. they are not part of the top layer of sediment considered in SimpleBox.

Burial is implemented based on the NETsedrate which is an input parameter in data (ScaleSubComprtData.csv)

```{r Burial}
World$fetchData("NETsedrate")
source("newAlgorithmScripts/k_Burial.R")


TestProcess <- World$NewProcess("k_Burial")
World$FromDataAndTo("k_Burial")
TestProcess$execute() # does not compute, likely due to all.NETsedrate (similar issue to k_Adsoprtion)

```



### Leaching

Leaching


```{r Leaching new}



World$fetchData("Kscompw")

source("newAlgorithmScripts/k_Leaching.R")

source("newAlgorithmScripts/f_CORRsoil.R")
#calculation of kaas is by executing a process
testClass <- World$NewProcess("k_Leaching")
World$fetchData("SpeciesName")
World$FromDataAndTo("k_Leaching")
testClass$execute()

source("baseScripts/ReorderCSV.R")


```

### Escape

t_half_Escape is added as constant. A 60 year half life is used in SB4 to calculate the rate constant for escape of chemicals from air to the stratosphere.


```{r k_Escape}

testClass <- World$NewProcess("k_Escape")
World$fetchData("SpeciesName")
World$FromDataAndTo("k_Leaching")
testClass$execute()


```



Explain how the exclusions and inclusions for where the functions are needed are added:
```{r}
ProcessXlsx <- "data/DEGradation.xlsx" 
processName <- unname(unlist(openxlsx::read.xlsx(ProcessXlsx, colNames=FALSE,
                                                 namedRegion = "process")))
TransDim <- unname(unlist(openxlsx::read.xlsx(ProcessXlsx, colNames=FALSE,
                                              namedRegion = "TransDim")))
fromTo <- openxlsx::read.xlsx(ProcessXlsx, colNames=TRUE,
                              namedRegion = "fromTo")
exceptions <- openxlsx::read.xlsx(ProcessXlsx, colNames=TRUE,
                                  namedRegion = "exceptions")

library(tidyverse)
source("baseScripts/fakeLib.R")
if (!TransDim %in% The3D) {
  stringsAsList <- as.list(c("TransDim should be one of", The3D))
  stop(do.call(paste, stringsAsList))
}
if(!all(names(exceptions) %in% The3D)) {
  stringsAsList <- as.list(c("exception columns should be empty or one of", The3D))
  stop(do.call(paste, stringsAsList))
}
if (TransDim %in% names(exceptions)) {
  stop("exception columns should differ from TransDim")
}



DefKeys <- read.csv("data/Defs.csv")
#obtain (unique) Defs in this!! order
DefDups <- duplicated(DefKeys$Defs)
Defs <- DefKeys$Defs[!DefDups]

MlikeWorkBook <- lapply(Defs, function(tableName) {
  assign(tableName, read.csv(
    paste("data/", tableName, ".csv", sep = "")))
})
names(MlikeWorkBook) <- Defs


for (TheDim in The3D) {#TheDim = The3D[1]
  dataFrameName <- paste(TheDim, "Processes", sep = "")
  dataFrame <- MlikeWorkBook[[dataFrameName]]
  ThisProcessRows <- dataFrame$process == processName
  if (any(ThisProcessRows)) {
    cat(paste("process updated in", dataFrameName))
    MlikeWorkBook[[dataFrameName]] <- dataFrame[!ThisProcessRows,]
  }
  #exceptions; as columns of
  dataFrameName <- paste(TheDim, "Sheet", sep = "")
  dataFrame <- MlikeWorkBook[[dataFrameName]]
  if (processName %in% names(dataFrame)) {
    cat(paste("exceptions updated in", dataFrameName))
    minCol <- match(processName, names(dataFrame))
    MlikeWorkBook[[dataFrameName]] <- dataFrame[, -minCol]
  }
}


dataFrameName <- paste(TransDim, "Processes", sep = "")
ReplacePart <- fromTo
ReplacePart$process <- processName
OldProcessData <- MlikeWorkBook[[dataFrameName]]
MlikeWorkBook[[dataFrameName]] <- rbind(
  OldProcessData,
  ReplacePart[,names(OldProcessData)])

#exceptions; as columns of
for (TheDim in names(exceptions)) {#TheDim = names(exceptions)[1]
  dataFrameName <- paste(TheDim, "Sheet", sep = "")
  dataFrame <- MlikeWorkBook[[dataFrameName]]
  ToFalse <- dataFrame[,TheDim] %in% exceptions[,TheDim]
  MlikeWorkBook[[dataFrameName]] <- dataFrame %>%
    mutate({{processName}} := !ToFalse)
}


source("baseScripts/ReorderCSV.R")

source("baseScripts/initTestWorld.R")
World$FromDataAndTo("k_DEGradation")
```

