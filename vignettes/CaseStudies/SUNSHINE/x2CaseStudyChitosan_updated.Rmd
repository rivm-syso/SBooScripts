---
title: "Case study Chitosan updated"
author: "Valerie de Rijk, Joris Quik, Jaap Slootweg, Anne Hids"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
library(tidyverse)
library(knitr)
```

## Initiation

We assume you have the input data for a substance or material of interest and all the data describing the SimpleBox world to be created ready and thus can run the initWorld script.

```{r message=FALSE, warning=FALSE, paged.print=TRUE}
source("baseScripts/initWorld_onlyParticulate.R")
substance <-  "GO-Chitosan"
World$substance <- substance
```

## Computing Spherical equivalent diameter

We calculate the spherical equivalent diameter (deq) and subsequently use it to overwrite radS. In this manner we include the shape of the considered particles. We update the matrix in the chunk after. [TODO: In future this could be included in the initialization for relevant particles that consist of multiple components]

We need the following properties for the GO-Chitosan related particles:

-   Shape

-   Size

-   Density

-   Other 'unknown' variables, such as attachment efficiency, etc.

| Property             | GO-Chitosan     | GO              | Chitoson         |
|----------------------|-----------------|-----------------|------------------|
| Shape                | Sheet-like      | Flake           | Fragment         |
| Size - square (LxB)  | 70 - 90 (80) um | 70 - 90 (80) um | 100-200 (150) nm |
| Size - thickness (H) | 10-20 (15) nm   | 1-10 (5) nm     | 100-200 (150) nm |
| Density              | Calculated      | 0.35 g/ml       | 0.874 g/ml       |

: The density of GO-chitosan is approximated by 1/8 \* dens_Graphene + 7/8 \* dens_Chitosan

```{r Computing Radius, message=FALSE, warning=FALSE}
Longest <- 80*1e-06
Intermediate <- 80*1e-06
Shortest <- 15*1e-9

Volume <- Longest*Intermediate*Shortest
d_eq <- ( 6/ pi * Volume)^(1/3)
rad_eq <- d_eq/2
print(rad_eq)

World$SetConst(RadS = rad_eq)

World$fetchData("RhoS")
World$UpdateKaas(mergeExisting = F)
```

## Adjusting Parameters with Uncertainty

Since attachment efficiencies (alpha) are very uncertain, below is a chunk where we can create distributions for these parameters. We start however with a deterministic calculation using averages.

```{r Example Uncertain Alpha, message=FALSE, warning=FALSE}
fwa_min <- 1e-4
fwa_max<- 0.1
n <- 100000
log_uniform_samples <- 10^runif(n, min = log10(fwa_min), max = log10(fwa_max))
fw_alpha_mean_log_samples <- mean(log_uniform_samples)

#Check with histogram 
hist(log_uniform_samples, breaks = 30, freq = FALSE,
     main = "Histogram of Log Uniform Distribution [10^-3, 10^-1]",
     xlab = "Value", ylab = "Density")
# Plot the probability density function (pdf) curve
curve(dunif(log10(x), min = log10(fwa_min), max = log10(fwa_max)) / x,
      from = fwa_min, to = fwa_max, add = TRUE, col = "blue", lwd = 2 )

#marine 
ma_min <- 1e-3 
ma_max <- 1
log_uniform_samples <- 10^runif(n, min = log10(ma_min), max = log10(ma_max))
marine_alpha_mean_log_samples <- mean(log_uniform_samples)


subcompartsmarine <- c("sea", "marinesediment", "freshwatersediment", "deepocean")

subcomparts <- c("river", "lake", "water", "agriculturalsoil", "naturalsoil", "othersoil")

all_subcomparts <- c(subcomparts, subcompartsmarine)

alpha = data.frame(
SubCompart = c(subcomparts,subcompartsmarine),  
alpha = c(fw_alpha_mean_log_samples, marine_alpha_mean_log_samples))

World$fetchData("alpha")
ToPaste <- lapply(list(alpha), function(x) {
  varName <- names(x)[!names(x) %in% The3D]
  stopifnot(length(varName)==1)
  as.data.frame(pivot_longer(data = x, cols = all_of(varName), names_to = "varName", values_to = "Waarde"))
})

dfs <- do.call(bind_rows, ToPaste)

World$mutateVars(dfs)

World$UpdateKaas(mergeExisting = F)
World$fetchData("alpha")
```

## NewSolver

Different solvers are available, basically:

1.  Solving the steadystate of the SimpleBox world

2.  Solving in time the states of SimpleBox world

Both will be illustrated bellow, but it starts with defining the solver you want to use by `world$NewSolver("[name of s_function]")`

### SBsteady

Currently there are two ways to solve the matrix in steady state, so with constant emission and infinite time horizon. These are:

1.  `SB1solve` - using solve from base R

2.  `SBsteady` - using runsteady from the rootSolve package

```{r SBsteady}
World$NewSolver("SBsteady")
```

What solving means is that using matrix algebra a set of differential equations is solved:

`K %*% m + e`

Where:

K is the matrix of rate constants for each process describing the mass transfers to and from and out of a state (e.g. substance in freshwater (w1U) or small hetero agglomerate in natural soil (s1A)).

m is the mass in each compartment, e.g. 0 at t=0.

e is the emission to each compartment per unit of time, e.g. 1 t/y.

Here, we define the emissions for a Steady State Calculation, based on averages for 2035 for GO-Chitosan. We convert the emissions to kg/s

```{r constant emission}
emissions <- data.frame(Abbr = c("aCS", "s2CS", "w1CS"), 
                        Emis = c(0.000047, 150, 43))
emissions$Emis<- emissions$Emis * 1000 / (365.25 * 24 * 60 * 60)
```

Now we are ready to run the solver, which results in the mass in each compartment.

```{r}
Solution <- World$Solve(emissions)
Solution <- as_tibble(Solution) 
```

We are also interested in concentrations per compartment. For this, we need to ensure that we convert the Equilibrium Mass into the Equilibrium concentration, which we will do below. We need to adjust the concentrations to end up in respective units. We convert concentrations in soil and sediment to ng/kg wet weight. Concentrations in water are converted in ng/L. In air, concentrations are in ng/kg air. The output is in the form of a table, with both the Equilibrium Mass and the concentration in the compartment per species.

```{r Calculate concentrations}
Concentration_SS <- 
  Solution |>
  left_join(World$fetchData("Volume"), 
            by=c("Scale", "SubCompart")) |>
  # Change 'cloudwater' to 'air', and then sum the masses and volumes of these compartments together
  mutate(SubCompart = ifelse(SubCompart == "cloudwater", "air", SubCompart)) |>
  ungroup() |> 
  group_by(Scale, SubCompart, Species) |>
  summarise(EqMass = sum(EqMass),
            Volume = sum(Volume)) |>
  ungroup() |>
  # Calculate the concentrations
  mutate(conc_kg_m3 = EqMass/Volume) |> 
  left_join(World$fetchData("FRACw"),
            by=c("Scale", "SubCompart")) |> 
  left_join(World$fetchData("FRACa"),
            by=c("Scale", "SubCompart")) |> 
  left_join(World$fetchData("rhoMatrix"),
            by=c("SubCompart")) |> 
  left_join(World$fetchData("Matrix"),
            by=c("SubCompart"))|> 
  mutate(Unit = "kg/m³") |> 
  mutate(Concentration =
           case_match(Matrix,
                      "air" ~ conc_kg_m3*1000000,
                      "water" ~ conc_kg_m3*1000,
                      "soil" ~ conc_kg_m3  / ((1 - FRACw - FRACa) * rhoMatrix)*1000, # RhoWater needed (we need to define subcompartment variables for rhoWater, rhoSolid and rhoAir)
                      "sediment" ~ conc_kg_m3  / ((1 - FRACw - FRACa) * rhoMatrix)*1000,
                      .default = conc_kg_m3),
         Unit =
           case_match(Matrix,
                      "air" ~ "mg/m³",
                      "water" ~ "mg/L",
                      "soil" ~ "g/kg dw",
                      "sediment" ~ "g/kg dw",
                      .default = Unit)) |>
  mutate(SubCompartName = paste0(SubCompart, " (", Unit, ")")) |>
  select(-c(conc_kg_m3, FRACw, FRACa, rhoMatrix, Matrix, Volume))
```


```{r Output Table, paged.print=TRUE}
SS_concentrations_table_continental <- Concentration_SS |>
  group_by(Scale, SubCompart, Unit) |>
  summarise(Concentration = sum(Concentration)) |>
  ungroup() |>
  mutate(Concentration = scientific(Concentration)) |>
  filter(Scale == "Continental")

kable(SS_concentrations_table_continental)

```

## DynApproxSolve

### Adjusting Parameters to Match considered Scale

In this case study we are considering emission data only for Europe. By default the 'World' is represented by a nested regional scale, which is not relevant for the current assessment using emissions data only for Europe. Here we use the option to allocate part of the emissions to the regional scale based on the fraction of surface area in order to mimic not having a nested scale. In future one would be interested for instance in including a local or national scale as well. One could adjust the regional scale for this purpose.

The code is commented out, but this is an example of adjusting the regional scale to represent Switzerland. You can only adjust parameters that are initial input data, not variables that are calculated later in SBOO. The adjusted dataframes are printed below. Note, at this point the input is already converted to SI units, so new data also needs to be put in this format.

```{r Scaling, include=FALSE}
# 
# LandFRAC <- data.frame(
#   Scale = "Regional",
#   SubCompart = c("agriculturalsoil", "lake", "naturalsoil", "othersoil" , "river"), 
#   landFRAC = c(0.37, 0.02, 0.51, 0.08, 0.02)
# )
# # TotalArea <- data.frame(
# #   Scale = c("Arctic", "Continental", "Moderate", "Regional"),
# #   TotalArea = c(4.25E+13, 7.43E+12, 8.50E+13, 4.13e+11)
# # )
# 
# Temperature <- data.frame(
#   Scale = "Regional", 
#   Temp = 279
# )
# 
# RAINrate <- data.frame(
#   Scale = "Arctic",
#   RAINrate = 4.37e-5
# )
# 
# ParamToAdjust <- list(LandFRAC, Temperature, RAINrate)
# for (i in seq_along(ParamToAdjust)) {
#   ParamToAdjust[[i]] <- World$mutateVar(ParamToAdjust[[i]])
# }
# print(ParamToAdjust)

## scaling of world 

Area <- World$fetchData("TotalArea")
AreaRegional <- Area$TotalArea[Area$Scale =="Regional"]
AreaContinental <- Area$TotalArea[Area$Scale =="Continental"]
fracReg <- AreaRegional/AreaContinental
fracCont <- 1-fracReg

FracRC <- tibble(
  Scale_SBname = c("Regional","Continental"),
  Abr_scale = c("R","C"),
  AreaFraction = c(fracReg,fracCont)
)

print(FracRC)

```

### Read in the DPMFA data

```{r emission data, include=FALSE}
file_paths <- 
  list.files("data/emissions",recursive = TRUE)
Emissions <-
  read_csv(paste0("data/emissions/",file_paths), id="file_name", col_names = c("RUN",0:24),skip = 1) # unit: Metric tonnes
```

### Prepare DPMFA data

Data from an DPMFA model should be prepared to fit the SBoo world. For instance the time unit should be correct, the mass unit is not as important as this will be the same in the output then, but for good measure we use kg. This is the quick and dirty way, a more elegant way is till in progress as mentioned above.

We define the compartments of the emission based on the DMPFA model.

*NOTE* all concentrations need to be in mass unit/s in order for the solver to work. This is due to the fact that the matrix operates in seconds

```{r Emissions, include=FALSE}
# TODO: solve for every RUN
Emissions_summarised <- 
  Emissions |>
  pivot_longer(
    cols = !c(file_name,RUN),
    names_to = "year",
    values_to = "emission_t" ) |> mutate_at('year',as.numeric) |> 
  ungroup() |> 
  group_by(file_name,year) |> 
  summarise(Emission_p50_kg = quantile(emission_t,probs = 0.5)*1000/(365.25*24*3600),
            Emission_mean_kg_s = mean(emission_t)*1000/(365.25*24*3600)) |> ungroup()

Emissions_summarised <- 
  Emissions_summarised |> 
  mutate(compartment = 
           case_when(str_detect(file_name, "(?i)Air") ~ "Air",
                     str_detect(file_name, "(?i)Soil") ~ "SludgeTreatedSoil",
                     str_detect(file_name, "(?i)Water") ~ "SurfaceWater",
                     str_detect(file_name, "(?i)Subsurface") ~ "Subsurface",
                     TRUE ~ "Other"),
         scale = 
           case_when(str_detect(file_name, "(?i)EU") ~ "EU_average",
                     str_detect(file_name, "(?i)Ireland") ~ "EU_STsoil",
                     str_detect(file_name, "(?i)Switzerland") ~ "EU_noSTsoil",
                     TRUE ~ "Other"),
         Substance = "GO-Chitosan",
  )

```

### Scaling Emission data based on material density

When running for only GO or only Chitosan, you want to correct for the fact that it's partly Chitosan and partly GO through using the densities.

```{r DensityScaling, include=FALSE}

Weightfactor <- switch(substance,
                       "GO-Chitosan" = 1,
                       "Chitosan" = 7/8,
                       "GO" = 1/8)

Emissions_summarised <-
  Emissions_summarised |> mutate(Emission_mean_kg_s = Emission_mean_kg_s* Weightfactor,
                      Emission_p50_kg = Emission_p50_kg*Weightfactor)

head(Emissions_summarised)

```

### Scaling Input Data based on World (Regional nested in Continental)

In this chunk, we adjust for the fact that the input data for the DMPFA model is all Europe based. Hence we scale by the factor fracReg and fracCont to still include the current regional scale (could alse be done differently). The regional data is thus a portion of the EU emission, scaled based on the land surface area.

```{r ScaleScaling, include=FALSE}

Emissions_scaled <- 
  Emissions_summarised |> mutate(
    Abr_comp =  case_match(compartment,
                           "Air" ~ "a",
                           "SludgeTreatedSoil" ~ "s2",
                           "SurfaceWater" ~ "w1",
                           .default = NA
    ),
    Abr_scale =  case_match(scale,
                            "EU_average" ~ "C",
                            .default = NA
    ),
    Abr_species = "S"
    
  ) |> drop_na() 

Emissions_scaled <-  
  Emissions_scaled |> rbind(
    Emissions_scaled |> 
      mutate(
        Abr_scale =  case_match(Abr_scale,
                                "C" ~ "R",
                                .default = NA
        ),
        scale = "EU_average"
      )
  ) |> full_join(FracRC) |> 
  
  mutate(Abr = paste0(Abr_comp,Abr_scale,Abr_species)) |> 
  mutate(Emission_mean_kg_s = Emission_mean_kg_s*AreaFraction,
         Emission_p50_kg = Emission_p50_kg*AreaFraction)

```

### Dynamic solving for deterministic input data

The chunk below gives the opportunity to Solve for constant input data. The chunk after that gives the opportunity to also vary SB Input data
```{r Solve using dynamic deterministic solver}
seconds_in_year <- 365.25*24*60*60

Emissions_scaled <- Emissions_scaled |>
  select(year, Abr, Emission_mean_kg_s) |>
  mutate(Timed = year*seconds_in_year+seconds_in_year) |> 
  ungroup() |>
  rename(Emis = Emission_mean_kg_s,
         Abbr = Abr)

World$NewSolver("DynApproxSolve")

Solution <- World$Solve(Emissions_scaled, tmax=max(Emissions_scaled$Timed), nTIMES = length(unique(Emissions_scaled$Timed))+1)
Solution <- as.data.frame(Solution) |>
  mutate(Year = time/seconds_in_year) |>
  select(-time)

Emission <- Solution |>
  select(Year, starts_with("emis"))

Solution <- Solution |>
  select(Year, !starts_with("emis"))
```

```{r Figures for dynamic output}

# Make plot comparing masses in each subcompartment at each scale
Solution_long <- Solution |>
  pivot_longer(!Year, names_to = "Abbr", values_to = "Mass") |>
  left_join(World$states$asDataFrame, by = "Abbr") |>
  group_by(Year, Scale, SubCompart) |>
  summarise(Mass = sum(Mass)) |>
  ungroup()

for(scale in c("Regional", "Continental")){
  scale_data <- Solution_long |>
    filter(Scale == scale)
  
  Scale_plot <- ggplot(scale_data, aes(x=Year, y=Mass, color=SubCompart)) +
    geom_line() +
    ggtitle(scale) +
    theme_bw()
  
  print(Scale_plot)
}
```

```{r Plot emissions that were used as input}
Emissions_plot <- Emissions_scaled |>
  left_join(World$states$asDataFrame, by = "Abbr") 

for(scale in unique(Emissions_plot$Scale)){
  scale_data <- Emissions_plot|>
    filter(Scale == scale)
  
  Scale_plot <- ggplot(scale_data, aes(x=Timed, y=Emis, color=SubCompart)) +
    geom_line() +
    ggtitle(scale) +
    labs(x="Time (s)", 
          y="Emission (kg)") +
    theme_bw()
  
  print(Scale_plot)
}

```

## From mass to concentration
In this chunk we will convert the mass output into concentration output by calculating the respective volumes and calculating by this value.

```{r Mass to concentration}
Concentration_long <- 
  Solution_long |>
  left_join(World$fetchData("Volume"), 
            by=c("Scale", "SubCompart")) |>
  # Change 'cloudwater' to 'air', and then sum the masses and volumes of these compartments together
  mutate(SubCompart = ifelse(SubCompart == "cloudwater", "air", SubCompart)) |>
  ungroup() |> 
  group_by(Year, Scale, SubCompart) |>
  summarise(Mass = sum(Mass),
            Volume = sum(Volume)) |>
  ungroup() |>
  # Calculate the concentrations
  mutate(conc_kg_m3 = Mass/Volume) |> 
  left_join(World$fetchData("FRACw"),
            by=c("Scale", "SubCompart")) |> 
  left_join(World$fetchData("FRACa"),
            by=c("Scale", "SubCompart")) |> 
  left_join(World$fetchData("rhoMatrix"),
            by=c("SubCompart")) |> 
  left_join(World$fetchData("Matrix"),
            by=c("SubCompart"))|> 
  mutate(Unit = "kg/m³") |> 
  mutate(Concentration =
           case_match(Matrix,
                      "air" ~ conc_kg_m3*1000000,
                      "water" ~ conc_kg_m3*1000,
                      "soil" ~ conc_kg_m3  / ((1 - FRACw - FRACa) * rhoMatrix)*1000, # RhoWater needed (we need to define subcompartment variables for rhoWater, rhoSolid and rhoAir)
                      "sediment" ~ conc_kg_m3  / ((1 - FRACw - FRACa) * rhoMatrix)*1000,
                      .default = conc_kg_m3),
         Unit =
           case_match(Matrix,
                      "air" ~ "mg/m³",
                      "water" ~ "mg/L",
                      "soil" ~ "g/kg dw",
                      "sediment" ~ "g/kg dw",
                      .default = Unit)) |>
  mutate(SubCompartName = paste0(SubCompart, " (", Unit, ")")) |>
  select(-c(conc_kg_m3, FRACw, FRACa, rhoMatrix, Matrix, Volume))
```

### Plot concentrations
The chunk below filters out the sediment compartments because there the concentrations is 0, 
and plots the concentrations for the Regional and Continental compartments. 

```{r Plot concentrations}
for(scale in c("Regional", "Continental")){
  scale_data <- Concentration_long |>
    filter(Scale == scale) |>
    filter(!str_detect(SubCompart, "sediment"))
  
  Scale_plot <- ggplot(scale_data, aes(x=Year, y=Concentration, color=SubCompartName)) +
    geom_line() +
    ggtitle(scale) +
    theme_bw()
  
  print(Scale_plot)
}
```
