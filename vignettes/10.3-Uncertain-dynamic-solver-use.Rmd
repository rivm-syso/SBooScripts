---
title: "Probabilistics Dynamic solver use"
author: "Anne Hids, Valerie de Rijk, Joris Quik, Jaap Slootweg"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Initialize World
First, we will load the neccesary packages and initialize the world for molecules

```{r Initialize World, warning=FALSE, message=FALSE}
library(lhs)
library(tidyverse)

source("baseScripts/initWorld_onlyMolec.R")
```

## Use of the dynamic uncertain solver 

There are four ways to use the UncertainDynamicSolver: 

1. With uncertain variables but one set of emissions as a dataframe
2. With uncertain variables but one set of emissions as a list of functions
3. With uncertain variables and variable emissions as a dataframe
4. With uncertain variables and variable emissions as lists of functions

The methods will be explained in the order of the list above.

### 1: Use the solver with uncertain variables and one set of emissions as a dataframe

#### Create tibble with samples for uncertain variables

The first step is to determine the number of uncertain variables and the number of runs.

```{r Create samples, warning=FALSE, message=FALSE}
# Define the number of samples and the number of variables
n_samples <- 100
n_vars <- 3

# Generate LHS
lhs_samples_vars <- randomLHS(n_samples, n_vars)
```

The lhs samples are pulled from a uniform distribution between 0 and 1. So these numbers have to be scaled to the real values you want to use, and it is possible to transform this uniform distribution to a different distribution. In this example, a triangular distribution will be used. 

Define triangular distribution function:
```{r Define triangular distribution function, warning=FALSE, message=FALSE}
# Triangular distribution function
triangular_cdf_inv <- function(u, # LH scaling factor
                               a, # Minimum
                               b, # Maximum
                               c) { # Peak value
  ifelse(u < (c-a)/(b-a),
         a + sqrt(u * (b-a) * (c-a)),
         b - sqrt((1-u) * (b-a) * (b-c)))
}
```

##### Prepare variable samples
Now we are ready to prepare the variable data and define the min, max and peak value of the distribution for each variable. 

In this example the following three variables are used: 

1. Molecular weight
2. Area for regional river
3. Erosion of agricultural soil

In the chunk below, the name, scale, subcompartment, min, max and peak value are defined for each variable.

```{r Get min, max and peak value of variable values, warning=FALSE, message=FALSE}
# Define the names of the uncertain variables
var1Name <- "kdeg"

var1 <- World$fetchData(var1Name) |>
  mutate(Scale = NA) |>
  filter(SubCompart == "river")

# Set the parameters for the triangular distribution
var1$a <- var1$kdeg*0.5    # Minimum value
var1$b <- var1$kdeg*1.5    # Maximum value
var1$c <- var1$kdeg        # peak value (peak)

# Define the names of the uncertain variables
var2Name <- "kdeg"

var2 <- World$fetchData(var2Name) |>
  mutate(Scale = NA) |>
  filter(SubCompart == "air")

# Set the parameters for the triangular distribution
var2$a <- var2$kdeg*0.5    # Minimum value
var2$b <- var2$kdeg*1.5    # Maximum value
var2$c <- var2$kdeg         # peak value (peak)

# Define the names of the uncertain variables
var3Name <- "kdeg"

var3 <- World$fetchData(var3Name) |>
  filter(SubCompart == "agriculturalsoil") |>
  mutate(Scale = NA)

# Set the parameters for the triangular distribution
var3$a <- var3$kdeg*0.5    # Minimum value
var3$b <- var3$kdeg*1.5    # Maximum value
var3$c <- var3$kdeg         # peak value (peak)
```

Now this data needs to be combined into a tibble, and the function for the triangular distribution written earlier is applied to the tibble. The result is a nested tibble, containing the name, scale and subcompartment for each variable, and the sample data is nested. 

```{r Scale the samples to the distributions, warning=FALSE, message=FALSE}
params <- tibble(
  varName = c(var1Name, var2Name, var3Name),
  Scale = c(var1$Scale, var2$Scale, var3$Scale),
  SubCompart = c(var1$SubCompart, var2$SubCompart, var3$SubCompart),
  data = list(
    tibble(id = c("a", "b", "c"), value = c(var1$a, var1$b, var1$c)),
    tibble(id = c("a", "b", "c"), value = c(var2$a, var2$b, var2$c)),
    tibble(id = c("a", "b", "c"), value = c(var3$a, var3$b, var3$c))
  )
)

sample_df <- params

# Transform each LHS sample column to the corresponding triangular distribution
for (i in 1:n_vars) {
  a <- filter(params$data[[i]], id == "a") %>% pull(value)
  b <- filter(params$data[[i]], id == "b") %>% pull(value)
  c <- filter(params$data[[i]], id == "c") %>% pull(value)
  
  samples <- triangular_cdf_inv(lhs_samples_vars[, i], a, b, c)
  
  # Create a new tibble for 'data' with samples replacing original values
  new_data <- tibble(value = samples)
  
  # Update the data column in the sample_df
  sample_df$data[[i]] <- new_data
}
```

##### Prepare emission data

In this example, we will use a dataframe with the emissions for several compartments at several times. These emissions are converted to a list of functions in the solver, so that emissions at other times can be estimated.

```{r Create dynamic emission dataframe, warning=FALSE, message=FALSE}
emissions <- data.frame(Abbr = c("aRU", "s2RU", "w1RU","aRU", "s2RU", "w1RU"), Emis = c(10, 10, 10,20, 20, 20), Timed = c(1, 2, 3, 4, 5, 6)) # convert 1 t/y to si units: kg/s

emissions <- emissions |>
  mutate(Timed = Timed*(365.25*24*60*60)) |> ungroup() |>
  mutate(Emis = Emis*1000/(365*24*60*60)) 

tmax <- 365.25*24*60*60*10
times <- seq(0, tmax, length.out = 10)
```

#### Solve 
The UncertainDynamicSolver is needed to apply simplebox probabilistically using a tibble with nested samples.

```{r Solve, warning=FALSE, message=FALSE}
# World$NewSolver("UncertainDynamicSolver")
# solved <- World$Solve(emissions, sample_df, tmax = tmax, needdebug = F)

```

### 2. With uncertain variables but one set of emissions as a list of functions

To demonstrate method 2, we can use the same set of uncertain variable samples as in method 1.

##### Prepare emission data

Instead of using the dataframe with emissions like in method 1, we will convert this dataframe into a list of functions.
```{r Create dynamic emission dataframe, warning=FALSE, message=FALSE}
emissions <- data.frame(Abbr = c("aRU", "s2RU", "w1RU","aRU", "s2RU", "w1RU"), Emis = c(10, 10, 10,20, 20, 20), Timed = c(1, 2, 3, 4, 5, 6)) # convert 1 t/y to si units: kg/s

emissions <- emissions |>
  mutate(Timed = Timed*(365.25*24*60*60)) |> ungroup() |>
  mutate(Emis = Emis*1000/(365*24*60*60)) 

tmax <- 365.25*24*60*60*10
times <- seq(0, tmax, length.out = 10)

SBEmissions3 <- 
  emissions |> 
  group_by(Abbr) |> 
  summarise(n=n(),
            EmisFun = list(
              approxfun(
                data.frame(Timed = c(0,Timed), 
                           Emis=c(0,Emis)),
                rule = 2) # Change to rule 1:1 for no extrapolation
            )
  )

funlist <- SBEmissions3$EmisFun
names(funlist) <- SBEmissions3$Abbr

```

#### Solve
```{r Solve, warning=FALSE, message=FALSE}
World$NewSolver("UncertainDynamicSolver")
solved2 <- World$Solve(funlist, sample_df, tmax = tmax, needdebug = F)

```

#### Prepare plot data
```{r example output plots}
Input_Variables <- 
  solved2$Input_Variables |> unnest(data) 

inputcomps <- unique(emissions$Abbr)

Input_Emission <- solved2$DynamicMass |>
  select(starts_with("emis2"), "time", "RUN") |>
  rename_with(
    .fn = ~ str_remove(.x, "emis2"),              # Function to add "_new" to column names
    .cols = !c("time", "RUN")  # Select columns to modify
  ) |>
  pivot_longer(cols = -c("time", "RUN"),
               names_to = "Abbr",
               values_to = "Emis") 

masses_long <- solved2$DynamicMass |>
  select(!starts_with("emis2")) |>
    rename_with(
    .fn = ~ paste0("mass_", .x),              # Function to add "_new" to column names
    .cols = !c("time", "RUN", "Unit") & !starts_with("emis")  # Select columns to modify
  ) |>
  pivot_longer(cols = starts_with("mass_"),
               names_to = "Abbr",
               values_to = "Mass") |>
  mutate(Abbr =  str_remove(Abbr, "mass_")) |>
  left_join(Input_Emission, by = c("Abbr", "time", "RUN")) |>
  left_join(solved2$States, by = "Abbr")

Plot_data <- 
  Input_Variables |> 
# some units missing resulting in NA
  pivot_wider(names_from = c(varName,Scale,SubCompart,Unit), values_from = value) |> 
  full_join(masses_long) |>
  mutate(time = time/(365.25*24*60*60))

datatmax <- Plot_data |>
  filter(time == tmax/(365.25*24*60*60)) |>
  left_join(solved2$States)

maxyear <- tmax/(365.25*24*60*60)

# Make plot theme

plot_theme <-  theme(
    axis.title.x = element_text(size = 14),    
    axis.title.y = element_text(size = 14),    
    axis.text.x = element_text(size = 12),     
    axis.text.y = element_text(size = 12),
    title = element_text(size=20)
  )

emiscomps <- unique(names(solved2$Input_Emission))
```

```{r Variable plots}
varnames <- colnames(Plot_data)[2:(1+n_vars)]

var_data <- Plot_data |> 
    filter(Abbr %in% emiscomps)

var_tmax <- datatmax |>
    filter(Abbr %in% emiscomps)

for(i in varnames) {
  p1 <- ggplot(var_data, mapping = aes(x = time, y = Mass, group = RUN, color = .data[[i]])) +  # Us
    geom_line() + 
    facet_wrap(vars(Abbr)) +
    labs(subtitle = "One set of emissions",
         x = "Time (years)", 
         y = "Mass (kg)", 
         color = i) +  # Use i as the label for color
    ggtitle("Mass in compartment over time (default substance)") +
    plot_theme
  print(p1)  # Use print() to ensure the plot is displayed in a loop
}

for(i in varnames) {
  p2 <- ggplot(var_tmax, mapping = aes(x = .data[[i]], y = Mass)) +
  geom_point() + 
  facet_wrap(vars(Abbr)) + 
  ggtitle(paste0("Mass in compartment at year ", as.character(maxyear))) + 
  labs(subtitle = "One set of emissions",
       x = i,  
       y = "Mass (kg)") +
  plot_theme                 
print(p2)
}

```

### Method 3: Use solver with uncertain variables and uncertain emissions as nested dataframe

#### Create tibble with samples for uncertain variables

The first step is to determine the number of uncertain variables and the number of runs.

```{r Create samples, warning=FALSE, message=FALSE}
# Define the number of samples and the number of variables
#n_samples <- 10
n_vars <- 3
n_comps <- length(unique(emissions$Abbr))
n_times <- length(unique(emissions$Timed))

n_lhs <- n_vars+(n_comps*n_times)

# Generate LHS
lhs_samples <- randomLHS(n_samples, n_lhs)

lhs_samples_vars <- lhs_samples[, 1:n_vars]

lhs_samples_emis <- lhs_samples[, (n_vars + 1):ncol(lhs_samples)]
```

##### Prepare variable samples
Now we are ready to prepare the variable data and define the min, max and peak value of the distribution for each variable. 

In this example the following three variables are used: 

1. Molecular weight
2. Area for regional river
3. Erosion of agricultural soil

In the chunk below, the name, scale, subcompartment, min, max and peak value are defined for each variable.

```{r Get min, max and peak value of variable values, warning=FALSE, message=FALSE}
# Define the names of the uncertain variables
var1Name <- "kdeg"

var1 <- World$fetchData(var1Name) |>
  mutate(Scale = NA) |>
  filter(SubCompart == "river")

# Set the parameters for the triangular distribution
var1$a <- var1$kdeg*0.5    # Minimum value
var1$b <- var1$kdeg*1.5    # Maximum value
var1$c <- var1$kdeg        # peak value (peak)

# Define the names of the uncertain variables
var2Name <- "kdeg"

var2 <- World$fetchData(var2Name) |>
  mutate(Scale = NA) |>
  filter(SubCompart == "air")

# Set the parameters for the triangular distribution
var2$a <- var2$kdeg*0.5    # Minimum value
var2$b <- var2$kdeg*1.5    # Maximum value
var2$c <- var2$kdeg         # peak value (peak)

# Define the names of the uncertain variables
var3Name <- "kdeg"

var3 <- World$fetchData(var3Name) |>
  filter(SubCompart == "agriculturalsoil") |>
  mutate(Scale = NA)

# Set the parameters for the triangular distribution
var3$a <- var3$kdeg*0.5    # Minimum value
var3$b <- var3$kdeg*1.5    # Maximum value
var3$c <- var3$kdeg         # peak value (peak)
```

Now this data needs to be combined into a tibble, and the function for the triangular distribution written earlier is applied to the tibble. The result is a nested tibble, containing the name, scale and subcompartment for each variable, and the sample data is nested. 

```{r Scale the samples to the distributions, warning=FALSE, message=FALSE}
params <- tibble(
  varName = c(var1Name, var2Name, var3Name),
  Scale = c(var1$Scale, var2$Scale, var3$Scale),
  SubCompart = c(var1$SubCompart, var2$SubCompart, var3$SubCompart),
  data = list(
    tibble(id = c("a", "b", "c"), value = c(var1$a, var1$b, var1$c)),
    tibble(id = c("a", "b", "c"), value = c(var2$a, var2$b, var2$c)),
    tibble(id = c("a", "b", "c"), value = c(var3$a, var3$b, var3$c))
  )
)

sample_df <- params

# Transform each LHS sample column to the corresponding triangular distribution
for (i in 1:n_vars) {
  a <- filter(params$data[[i]], id == "a") %>% pull(value)
  b <- filter(params$data[[i]], id == "b") %>% pull(value)
  c <- filter(params$data[[i]], id == "c") %>% pull(value)
  
  samples <- triangular_cdf_inv(lhs_samples_vars[, i], a, b, c)
  
  # Create a new tibble for 'data' with samples replacing original values
  new_data <- tibble(value = samples)
  
  # Update the data column in the sample_df
  sample_df$data[[i]] <- new_data
}
```

##### Prepare emission data
```{r Prepare nested emission df} 
# Define the names of the uncertain variables
comp1Name <- "aRU"

comp1 <-  emissions |>
  filter(Abbr == comp1Name)

# Set the parameters for the triangular distribution
comp1$a <- comp1$Emis*0.7    # Minimum value
comp1$b <- comp1$Emis*1.3    # Maximum value
comp1$c <- comp1$Emis        # Mode (peak)

comp1 <- comp1 |>
  select(-Emis)

# Define the names of the uncertain variables
comp2Name <- "s2RU"

comp2 <-  emissions |>
  filter(Abbr == comp2Name)

# Set the parameters for the triangular distribution
comp2$a <- comp2$Emis*0.7    # Minimum value
comp2$b <- comp2$Emis*1.3    # Maximum value
comp2$c <- comp2$Emis        # Mode (peak)

comp2 <- comp2 |>
  select(-Emis)

# Define the names of the uncertain variables
comp3Name <- "w1RU"

comp3 <-  emissions |>
  filter(Abbr == comp3Name)

# Set the parameters for the triangular distribution
comp3$a <- comp3$Emis*0.7    # Minimum value
comp3$b <- comp3$Emis*1.3    # Maximum value
comp3$c <- comp3$Emis        # Mode (peak)

comp3 <- comp3 |>
  select(-Emis)

params <- rbind(comp1, comp2, comp3)

emis_df <- params

# Transform each LHS sample column to the corresponding triangular distribution
for (i in 1:nrow(params)) {
  a <- params$a[i]
  b <- params$b[i]
  c <- params$c[i]
  
  samples <- triangular_cdf_inv(lhs_samples_emis[, i], a, b, c)
  
  # Create a new tibble for 'data' with samples replacing original values
  new_data <- tibble(value = samples)
  
  # Update the data column in the sample_df
  emis_df$Emis[[i]] <- new_data
}

emis_df <- emis_df |>
  select(Abbr, Timed, Emis)

```

#### Solve
```{r Solve, warning=FALSE, message=FALSE}
World$NewSolver("UncertainDynamicSolver")
solved3 <- World$Solve(emis_df, sample_df, tmax = tmax, needdebug = F)

# first get the abbreviations of the compartments that have emissions
emiscomps <- unique(solved3$Input_Emission$Abbr)

```

### Method 4: Use solver with uncertain variables and uncertain emissions as nested list of functions

For this method, we can use the same nested tibble with uncertain variables as in method 3. 

##### Prepare emission data

We will now make a nested tibble containing lists of approx funs for each run.
```{r Emissions nested list}
fun_tibble <- tibble(
  Abbr = character(),
  EmisFun = list(),
  RUN = integer()
)

for(i in 1:nrow(lhs_samples_emis)){
  fun_df <- emis_df |>
    select(-Emis)
  fun_df$Emis <- map(emis_df$Emis, ~ .x$value[i])
  
  SBEmissions3 <- 
    fun_df |> 
    group_by(Abbr) |> 
    summarise(n=n(),
              EmisFun = list(
                approxfun(
                  data.frame(Timed = c(0,Timed), 
                             Emis=c(0,Emis)),
                  rule = 2) # Change to rule 1:1 for no extrapolation
              )
    ) |>
    select(-n)
  
  SBEmissions3$RUN <- i
  
  fun_tibble <- rbind(fun_tibble, SBEmissions3) |>
    filter(!is.na(RUN))
}

final_fun_tibble <- fun_tibble |>
  group_by(Abbr) |>
  summarize(Funlist = list(EmisFun))

```

#### Solve
```{r Solve, warning=FALSE, message=FALSE}
# World$NewSolver("UncertainDynamicSolver")
# solved <- World$Solve(final_fun_tibble, sample_df, tmax = tmax, needdebug = F)

```


#### Prepare plot data
```{r example output plots}
Input_Variables <- 
  solved3$Input_Variables |> unnest(data) 

inputcomps <- unique(emissions$Abbr)

Input_Emission <- solved3$DynamicMass |>
  select(starts_with("emis2"), "time", "RUN") |>
  rename_with(
    .fn = ~ str_remove(.x, "emis2"),              # Function to add "_new" to column names
    .cols = !c("time", "RUN")  # Select columns to modify
  ) |>
  pivot_longer(cols = -c("time", "RUN"),
               names_to = "Abbr",
               values_to = "Emis") 

masses_long <- solved3$DynamicMass |>
  select(!starts_with("emis2")) |>
    rename_with(
    .fn = ~ paste0("mass_", .x),              # Function to add "_new" to column names
    .cols = !c("time", "RUN", "Unit") & !starts_with("emis")  # Select columns to modify
  ) |>
  pivot_longer(cols = starts_with("mass_"),
               names_to = "Abbr",
               values_to = "Mass") |>
  mutate(Abbr =  str_remove(Abbr, "mass_")) |>
  left_join(Input_Emission, by = c("Abbr", "time", "RUN")) |>
  left_join(solved3$States, by = "Abbr")

Plot_data <- 
  Input_Variables |> 
# some units missing resulting in NA
  pivot_wider(names_from = c(varName,Scale,SubCompart,Unit), values_from = value) |> 
  full_join(masses_long) |>
  mutate(time = time/(365.25*24*60*60))

datatmax <- Plot_data |>
  filter(time == tmax/(365.25*24*60*60)) |>
  left_join(solved3$States)

maxyear <- tmax/(365.25*24*60*60)
```

```{r Variable plots}
varnames <- colnames(Plot_data)[2:(1+n_vars)]

var_data <- Plot_data |> 
    filter(Abbr %in% emiscomps)

var_tmax <- datatmax |>
    filter(Abbr %in% emiscomps)

for(i in varnames) {
  p1 <- ggplot(var_data, mapping = aes(x = time, y = Mass, group = RUN, color = .data[[i]])) + 
    geom_line() + 
    facet_wrap(vars(Abbr)) +
    labs(subtitle = "Uncertain emissions",
         x = "Time (years)", 
         y = "Mass (kg)", 
         color = i) +  
    ggtitle("Mass in compartment over time (default substance)") +
    plot_theme
  print(p1) 
}

for(i in varnames) {
  p2 <- ggplot(var_tmax, mapping = aes(x = .data[[i]], y = Mass)) +
  geom_point() + 
  facet_wrap(vars(Abbr)) + 
  ggtitle(paste0("Mass in compartment at year ", as.character(maxyear))) + 
  labs(subtitle = "Uncertain emissions",
       x = i,  
       y = "Mass (kg)") +
  plot_theme                 
print(p2)
}

```

```{r Emission plots}
# Filter the plot data for the compartments that received emissions
EM_data <- Plot_data |>
  filter(Abbr %in% emiscomps)

EM_tmax <- datatmax |>
  filter(Abbr %in% emiscomps)

# Plot the emissions against the masses for these compartments
EM_p1 <- ggplot(EM_tmax, mapping = aes(x = Emis, y = Mass)) +
  geom_point() + 
  facet_wrap(vars(Abbr)) +
  ggtitle("Relation between emissions and mass") + 
  labs(subtitle = "Uncertain emissions",
       x = "Emissions (kg/s)",
       y = "Mass (kg)") + 
  plot_theme
EM_p1

```
