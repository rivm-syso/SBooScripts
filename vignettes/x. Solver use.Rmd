---
title: "Solver use"
author: "Anne Hids, Jaap Slootweg, Joris Quik"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Initialize World

First, we will load the necessary packages and initialize the world for molecules.

```{r Initialize World, warning=FALSE, message=FALSE}
library(lhs)
library(tidyverse)

source("baseScripts/initWorld_onlyMolec.R")
```

If you would like to instead initialize the World for particulates or microplastics, use: - source("baseScripts/initWorld_onlyParticulate.R") - source("baseScripts/initWorld_onlyMicroplastics.R")

## Steady state solver

A steady state solver calculates the masses in each environmental compartment (i.e. air, riverwater, naturalsoil) at each scale (i.e. Regional, Continental) when the system has reached an equilibrium.

There are two ways to use the steady state solver: deterministically (solve once with one set of emissions and one set of substance variables), or probabilistically (solve multiple times, once for each run with uncertain substance variables and optionally uncertain emissions).

### Use the steady state solver deterministically

We already initialized the simplest version of the World in the previous chunk. This means the World was initialized for 'default substance', which behaves as a molecule.

As we will not vary any substance variables when using the deterministic steady state solver, we only need to make a dataframe containing the emissions for 1 or more compartments. This dataframe should contain two columns: - 'Abbr', which contains the abbreviations for the compartments - 'Emis', which contains the emissions to the compartments, in kg/s.

To see the abbreviations and their meaning, you can run \`World\$states\$asDataFrame\`.

```{r Make emission dataframe for steady state deterministic solver, warning=FALSE, message=FALSE}
# Create the steady state emission dataframe
emissions <- data.frame(Abbr = c("aRU", "s2RU", "w1RU"), Emis = c(10000, 10000, 10000)) 

# convert 1 t/y to si units: kg/s
emissions <- emissions |>
  mutate(Emis = Emis*1000/(365*24*60*60)) 
```

Now we will initialize the solver, with is "SteadyODE" for all steady state calculations. Consequently, we will use the `World$Solve()` function to calculate the masses in each compartment.

```{r Solve steady state deterministically, warning=FALSE, message=FALSE}
# Define the solver function to use. For steady state calculations, this is always "SteadyODE"
World$NewSolver("SteadyODE")

# Solve with the emissions we defined in the previous chunk
World$Solve(emissions = emissions)
```

Finally we can retrieve the masses, emissions and concentrations from the World object by using the functions in the chunk below.

```{r Get solution emissions and concentration, warning=FALSE, message=FALSE}
# Get the solution(=mass per compartment), emissions and concentrations from 'World'
solution <- World$Solution()
emission <- World$Emissions()
concentration <- World$Concentration()
```

### Use the steady state solver probabilistically

```{r Prepare uncertain steady emissions}
source('baseScripts/initWorld_onlyPlastics.R')
World$NewSolver("SteadyODE")
load("vignettes/example_uncertain_data.RData")

example_data <- example_data |>
  select(To_Compartment, `2023`, RUN) |>
  rename("Emis" = `2023`) |>
  mutate(Abbr = case_when(
    To_Compartment == "Agricultural soil (micro)" ~ "s2RS",
    To_Compartment == "Residential soil (micro)" ~ "s3RS",
    To_Compartment == "Surface water (micro)" ~ "w1RS"
  )) |>
  mutate(Emis = (Emis*1000000)/(365.25*24*3600)) |> # Convert kt/year to kg/s
  select(-To_Compartment) 
```

```{r Prepare variable df and functions}
# Load the Excel file containing example distributions for variablese
Example_vars <- readxl::read_xlsx("vignettes/Example_uncertain_variables.xlsx", sheet = "Variable_data")

# Define functions for each row based on the distribution type
varFuns <- apply(Example_vars, 1, function(aRow) {
  dist_type <- aRow["Distribution"]
  
  if (dist_type == "triangular") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b", "c")]))
    names(prepArgs) <- c("a", "b", "c")
  } else if (dist_type == "normal") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b")]))
    names(prepArgs) <- c("a", "b")
  } else if (dist_type == "uniform") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b")]))
    names(prepArgs) <- c("a", "b")
  } else {
    stop("Unsupported distribution type")
  }
  
  # Create the inverse CDF function using the prepared arguments
  World$Make_inv_unif01(fun_type = dist_type, pars = prepArgs)
})
```

```{r Use the solver}
World$NewSolver("SteadyODE")
World$Solve(emissions = example_data, var_box_df = Example_vars, var_invFun = varFuns, nRUNs = length(unique(example_data$RUN)))
solution = World$Solution()
varvals = World$VariableValues()
concentration = World$Concentration()
emis = World$Emissions()
```

## Dynamic solver
To demonstrate the use of the dynamic solvers we will initialize the World for microplastics first:

```{r Init world microplastics, warning=FALSE, message=FALSE}
source('baseScripts/initWorld_onlyPlastics.R')
```

### Use the dynamic solver deterministically

When the World is initialized for particulates or plastics, the emissions go to the "S", "A" and/or "P" species (this is unlike emissions for molecules, where the emissions go to the "U" species).

| Abbreviation | Full species name |
|--------------|-------------------|
| U            | Unbound           |
| S            | Solid             |
| A            | Aggregated        |
| P            | Attached          |

: Species abbreviations and the corresponding species names.

```{r Test dynamic deterministic solver with emission df, warning = FALSE, message="FALSE"}
emissions <- data.frame(Abbr = c("aRS", "s2RS", "w1RS","aRS", "s2RS", "w1RS"), Emis = c(10, 10, 10, 20, 20, 20), Timed = c(1, 2, 3, 4, 5, 6)) # convert 1 t/y to si units: kg/s

emissions <- emissions |>
  mutate(Timed = Timed*(365.25*24*60*60)) |> ungroup()

tmax <- 365.25*24*60*60*10
nTIMES <- length(seq(0, tmax, length.out = 10))

World$NewSolver("ApproxODE")
World$Solve(emissions = emissions, tmax = tmax, nTIMES = nTIMES)
solution <- World$Solution()
emission <- World$Emissions()

PlotMass <- function(abbr){
  sol <- World$Solution() |>
    filter(Abbr == abbr) |>
    mutate(time = as.numeric(time))|>
    mutate(Year = time/(365.25*24*3600))
  
  plot <- ggplot(sol, aes(x = Year, y = Mass_kg)) + 
    theme_bw() + 
    geom_line() 
}

print(PlotMass("s1CS"))
```

## Use the dynamic solver probabilistically 

```{r Prepare uncertain steady emissions}
source('baseScripts/initWorld_onlyPlastics.R')
World$NewSolver("SteadyODE")
load("vignettes/example_uncertain_data.RData")

example_data <- example_data |>
  select(To_Compartment, `2020`, `2021`,`2022`, `2023`, RUN) |>
  pivot_longer(!c(To_Compartment, RUN), names_to = "year", values_to = "Emis") |>
  mutate(Abbr = case_when(
    To_Compartment == "Agricultural soil (micro)" ~ "s2RS",
    To_Compartment == "Residential soil (micro)" ~ "s3RS",
    To_Compartment == "Surface water (micro)" ~ "w1RS"
  )) |>
  select(-To_Compartment) |>
  mutate(Timed = ((as.numeric(year)-2019)*365.25*24*3600)) |>
  mutate(Emis = (Emis*1000000)/(365.25*24*3600)) |> # Convert kt/year to kg/s
  select(-year)
```

```{r Prepare variable df and functions}
# Load the Excel file containing example distributions for variablese
Example_vars <- readxl::read_xlsx("vignettes/Example_uncertain_variables.xlsx", sheet = "Variable_data")

# Define functions for each row based on the distribution type
varFuns <- apply(Example_vars, 1, function(aRow) {
  dist_type <- aRow["Distribution"]
  
  if (dist_type == "triangular") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b", "c")]))
    names(prepArgs) <- c("a", "b", "c")
  } else if (dist_type == "normal") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b")]))
    names(prepArgs) <- c("a", "b")
  } else if (dist_type == "uniform") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b")]))
    names(prepArgs) <- c("a", "b")
  } else {
    stop("Unsupported distribution type")
  }
  
  # Create the inverse CDF function using the prepared arguments
  World$Make_inv_unif01(fun_type = dist_type, pars = prepArgs)
})

```

```{r Use the solver}
World$NewSolver("ApproxODE")

tmax <- 365.25*24*60*60*length(unique(example_data$Timed))
nTIMES <- length(seq(0, tmax, length.out = 10))

World$Solve(emissions = example_data, var_box_df = Example_vars, var_invFun = varFuns, nRUNs = length(unique(example_data$RUN)), tmax = tmax, nTIMES = nTIMES)
solution = World$Solution()
```

<!-- ### Use the solver with uncertain variables and uncertain emissions as a set of functions -->

<!-- #### Create tibble with samples for uncertain variables -->

<!-- The first step is to define the solver to use. For all steady state calculations, this solver is named SteadyODE. -->

<!-- ```{r Define solver, warning=FALSE, message=FALSE} -->
<!-- World$NewSolver("SteadyODE") -->
<!-- ``` -->

<!-- The lhs samples are pulled from a uniform distribution between 0 and 1. So these numbers have to be scaled to the real values you want to use, and it is possible to transform this uniform distribution to a different distribution. In this example, a triangular distribution will be used. -->

<!-- ##### Prepare variable samples -->

<!-- For each variable that is uncertain you can define the distribution type (triangular, uniform or normal) and the corresponding parameters. For this example, an example excel file will be read in containing the necessary parameters for the variables we want to vary. -->

<!-- ```{r Get min, max and peak value of variable values, warning=FALSE, message=FALSE} -->
<!-- source("baseScripts/initWorld_onlyMolec.R") -->
<!-- World$NewSolver("SteadyODE") -->
<!-- # Load the Excel file containing example distributions for variables -->

<!-- Example_vars <- readxl::read_xlsx("vignettes/Example_uncertain_variables.xlsx", sheet = "Variable_data") -->

<!-- # Define functions for each row based on the distribution type -->
<!-- varFuns <- apply(Example_vars, 1, function(aRow) { -->
<!--   dist_type <- aRow["Distribution"] -->

<!--   if (dist_type == "triangular") { -->
<!--     prepArgs <- as.list(as.numeric(aRow[c("a", "b", "c")])) -->
<!--     names(prepArgs) <- c("a", "b", "c") -->
<!--   } else if (dist_type == "normal") { -->
<!--     prepArgs <- as.list(as.numeric(aRow[c("a", "b")])) -->
<!--     names(prepArgs) <- c("a", "b") -->
<!--   } else if (dist_type == "uniform") { -->
<!--     prepArgs <- as.list(as.numeric(aRow[c("a", "b")])) -->
<!--     names(prepArgs) <- c("a", "b") -->
<!--   } else { -->
<!--     stop("Unsupported distribution type") -->
<!--   } -->

<!--   # Create the inverse CDF function using the prepared arguments -->
<!--   World$Make_inv_unif01(fun_type = dist_type, pars = prepArgs) -->
<!-- }) -->
<!-- ``` -->

<!-- ##### Prepare emission data -->

<!-- In this example, we will take a steady state emission data frame as the starting point for creating the triangular distributions. You could also directly enter the min, max and peak values if you have them. -->

<!-- ```{r Create steady state emission dataframe, warning=FALSE, message=FALSE} -->
<!-- # Create the steady state emission dataframe -->
<!-- emissions <- data.frame(Abbr = c("aRU", "s2RU", "w1RU"), Emis = c(10000, 10000, 10000)) -->

<!-- # convert 1 t/y to si units: kg/s -->
<!-- emissions <- emissions |> -->
<!--   mutate(Emis = Emis*1000/(365*24*60*60)) -->
<!-- ``` -->

<!-- Now that the emission data frame is made, we can scale the samples we took earlier to the triangular distribution just like we did for the variables. -->

<!-- ```{r Scale the emissions to the distributions, warning=FALSE, message=FALSE} -->
<!-- emissions$a <- emissions$Emis * 0.7 -->
<!-- emissions$b <- emissions$Emis * 1.3 -->

<!-- emisFuns <- apply(rowwise(emissions) |> select(a, b, Emis), 1, function(therow){ -->
<!--   abcArgs <- as.list(as.numeric(therow)) -->
<!--   names(abcArgs) <- c("a", "b", "c") -->
<!--   World$Make_inv_unif01("triangular", abcArgs) -->
<!-- }) -->

<!-- # to identify the box by Abbr -->
<!-- names(emisFuns) <- emissions$Abbr -->
<!-- ``` -->

<!-- ```{r Test steady state uncertain solver, warning=FALSE, message=FALSE} -->
<!-- # The number of samples you want to pull from the distributions for each variable -->
<!-- n_samples <- 2 -->
<!-- World$NewSolver("SteadyODE") -->

<!-- World$Solve(emissions = emisFuns, var_box_df = Example_vars, var_invFun = varFuns, nRUNs = n_samples) -->

<!-- sol <- World$Solution() -->
<!-- conc <- World$Concentration() -->
<!-- ``` -->
