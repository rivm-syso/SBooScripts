---
title: "Solver use"
author: "Anne Hids, Jaap Slootweg, Joris Quik"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Initialize World
First, we will load the necessary packages and initialize the world for molecules

```{r Initialize World, warning=FALSE, message=FALSE}
library(lhs)
library(tidyverse)

source("baseScripts/initWorld_onlyMolec.R")
```

## Steady state solver

### Use the solver with uncertain variables and uncertain emissions as a set of functions

#### Create tibble with samples for uncertain variables

The first step is to define the solver to use. For all steady state calculations, this solver is named SteadyODE. 

```{r Define solver, warning=FALSE, message=FALSE}
#ConcDividerVar <- World$NewCalcVariable("Mass2ConcDivider")
World$NewSolver("SteadyODE")
```

The lhs samples are pulled from a uniform distribution between 0 and 1. So these numbers have to be scaled to the real values you want to use, and it is possible to transform this uniform distribution to a different distribution. In this example, a triangular distribution will be used. 

<!-- Define triangular distribution function: -->
<!-- ```{r Define triangular distribution function, warning=FALSE, message=FALSE} -->
<!-- triangular_cdf_inv <- World$Make_inv_unif01(fun_type = "triangular", pars = list (a=0.5, b=1.5, c=1)) -->
<!-- par(mfrow = c(1, 2)) -->
<!-- curve(triangular_cdf_inv, from = 0, to = 1) -->
<!-- #check sampling  -->
<!-- hist(triangular_cdf_inv(runif(5000)), breaks = 40) -->
<!-- par(mfrow = c(1, 2)) -->
<!-- ``` -->

##### Prepare variable samples
For each variable that is uncertain you can define the distribution type (triangular, uniform or normal) and the corresponding parameters. For this example, an example excel file will be read in containing the necessary parameters for the variables we want to vary. 

```{r Get min, max and peak value of variable values, warning=FALSE, message=FALSE}
# Load the Excel file containing example distributions for variablese
Example_vars <- readxl::read_xlsx("vignettes/Example_uncertain_variables.xlsx", sheet = "Variable_data")

# Define functions for each row based on the distribution type
varFuns <- apply(Example_vars, 1, function(aRow) {
  dist_type <- aRow["Distribution"]
  
  if (dist_type == "triangular") {
    prepArgs <- as.list(as.numeric(aRow[c("a", "b", "c")]))
    names(prepArgs) <- c("a", "b", "c")
  } else if (dist_type == "normal") {
    prepArgs <- as.list(as.numeric(aRow[c("mean", "sigma")]))
    names(prepArgs) <- c("mean", "sigma")
  } else if (dist_type == "uniform") {
    prepArgs <- as.list(as.numeric(aRow[c("min", "max")]))
    names(prepArgs) <- c("min", "max")
  } else {
    stop("Unsupported distribution type")
  }
  
  # Create the inverse CDF function using the prepared arguments
  World$Make_inv_unif01(fun_type = dist_type, pars = prepArgs)
})
```

##### Prepare emission data

In this example, we will take a steady state emission data frame as the starting point for creating the triangular distributions. You could also directly enter the min, max and peak values if you have them.

```{r Create steady state emission dataframe, warning=FALSE, message=FALSE}
# Create the steady state emission dataframe
emissions <- data.frame(Abbr = c("aRU", "s2RU", "w1RU"), Emis = c(10000, 10000, 10000)) 

# convert 1 t/y to si units: kg/s
emissions <- emissions |>
  mutate(Emis = Emis*1000/(365*24*60*60)) 
```

Now that the emission data frame is made, we can scale the samples we took earlier to the triangular distribution just like we did for the variables.

```{r Scale the emissions to the distributions, warning=FALSE, message=FALSE}
emissions$a <- emissions$Emis * 0.7
emissions$b <- emissions$Emis * 1.3

emisFuns <- apply(rowwise(emissions) |> select(a, b, Emis), 1, function(therow){
  abcArgs <- as.list(as.numeric(therow))
  names(abcArgs) <- c("a", "b", "c")
  World$Make_inv_unif01("triangular", abcArgs)
})

# to identify the box by Abbr
names(emisFuns) <- emissions$Abbr
```

```{r Test steady state uncertain solver, warning=FALSE, message=FALSE}
# The number of samples you want to pull from the distributions for each variable
n_samples <- 2 
World$NewSolver("SteadyODE")

World$Solve(emissions = emisFuns, var_box_df = Example_vars, var_invFun = varFuns, uncertain_emis = T)

sol <- World$Solution()
conc <- World$Concentration()

```

```{r Test steadt state deterministic solver, warning=FALSE, message=FALSE}
World$NewSolver("SteadyODE")



```


```{R Test Dynamic, warning=FALSE, message=FALSE}
# Create example functions
fun1 <- function(x) x + 1
fun2 <- function(x) x * 2
fun3 <- function(x) x^2

# Create a tibble with an 'Abbr' column and a 'Funlist' column containing lists of functions
final_fun_tibble <- tibble(
  Abbr = c("A", "B", "A"),
  EmisFun = list(fun1, fun2, fun3)
)

# Group by 'Abbr' and summarize to create a list of functions for each group
final_fun_tibble <- final_fun_tibble |> 
  group_by(Abbr) |> 
  summarize(Funlist = list(EmisFun))

print(length(final_fun_tibble$Funlist[[1]]))

# Print the tibble
print(final_fun_tibble)


fun1 <- function(x) x + 1
fun2 <- function(x) x * 2
fun3 <- function(x) x^2

# Create a nested list
nested_list <- list(
  A = list(fun1, fun3),  # Group A with two functions
  B = list(fun2)         # Group B with one function
)

length(nested_list[[2]])

#World$NewSolver("ApproxODE")

tmax <- 20*365*24*3600
nTIMES <- 20

World$Solve(emissions = emisFuns, tmax = tmax, nTIMES = nTIMES, uncertain_emis = F, var_box_df = Example_vars, var_invFun = varFuns, nRUNs = n_samples)

sol <- World$Solution()
conc <- World$Concentration()
emis <- World$Emissions()

# behind the scenes:
# library(lhs)

# n_lhs <- n_vars + n_emiscomps # Total number of vectors to create with latin hypercube sampling (lhs)

# lhs_samples <- optimumLHS(n_samples, n_lhs) # Generate numbers between 0 and 1 using lhs

# # Separate the samples for the variable and emission distributions from each other:
# lhs_samples_vars <- lhs_samples[, 1:n_vars] 
# lhs_samples_emis <- lhs_samples[, (n_vars + 1):ncol(lhs_samples)]
```
