---
title: "classic solve"
author: "JS"
date: "12 Apr 2022"
output: github_document
---

```{r setup, include=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

## Solve
This vignettes demonstrates solving the "engine" of SB, the matrix of the matrix of first order rate constants (k's) between all boxes ("kaas"). The first chunk will initialize World (the core object) with the special stateModule ClassicExcel, an object to explore the excel version of SB, and read emissions from it.
```{r}
#We need to initialize, by default a molecular substance is selected
source("baseScripts/initTestWorld.R")
#library(magrittr)
library(htmlTable)
ClassicExcel
excelReference
```
ClassicExcel is a ProcessModule, because it sets rate constants. In this case by reading all the excel variables looking like k.b1.b2 (where b1 and b2 are boxes, or states) in the file given by excelReference. The name of the process is LoadKaas. You can use this to update processes one by one and compare with the excel-version. We can also make a view of the k's, creating a selection of from-states and to-states.

```{r}
World$kaas[World$kaas$fromScale == "Regional" & World$kaas$toScale == "Continental",]
```
Yes, there is only advection by air and water... The empty to-columns indicate no change from the equivalent from-column. A transfer, and therefor a rate-constant, has a maximum of 1 change of scale, OR SubCompart OR Species; degradation for example has none.

## A Solver
Like processes, solvers are build on simple R functions, supported by R6 objects. Initiating a solver as part of the core World object take 4 lines of code to demonstrate; first the code of the most simple solver, than the core-method of initiating, and finally executing it.
Note that a solver needs a reference to it's "ParentModule". (Actual inheriting would make the function look more complex). When calling the solver from Core, this is provided for.

```{r}
SB1Solve
World$NewSolver("SB1Solve", tol=1e-10)
emissions <- ClassicExcel$ExcelEmissions("current.settings")
World$Solve(emissions)
```

## The constants package
Some global constants are imported from this package. For convenience two functions are availeable, demonstrated below.
```{r}
Concentrations <- function(EqMass, Volume) {
  EqMass / Volume
}
World$NewCalcVariable("Concentrations")
ConcPM <- World$CalcVar("Concentrations")
pivot_wider(ConcPM[, c("SubCompart", "Scale", "Concentrations")],
            values_from = "Concentrations",
            values_fill = NULL,
            names_from = "Scale")
# tidyHtmlTable(
#   x = ConcPM[, c("SubCompart", "Scale", "Concentrations")],
#   value = "Concentrations",
#   header = "Scale",
#   rnames = "SubCompart",
#   #col.header = "#FEFEFE",
#   col.rgroup = c("#FEFEFE", "#F7F7F7")
# )
```
## Mass fluxes
```{r}
MsFlux <- left_join(World$kaas, World$fetchData("EqMass"), 
                    join_by(fromScale == Scale, fromSubCompart == SubCompart, fromSpecies == Species))
MsFlux$mFlux <- MsFlux$k * MsFlux$EqMass
aggregate(mFlux~toAbbr, data = MsFlux, FUN = sum)
``` 
accuracy? Roundings?? tol doesn't make a difference?!

Happy calculations!
