---
title: "Test template to test a sboo variable"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::knit_meta()
# knitr::opts_chunk$set(echo = TRUE)
projectRoot <- paste(getwd(), "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

# introduction

Simple Box (the OO R version) distinguishes processes, which calculate (parts of) first order constants, and variables that are input to the processes. This script describes the steps to test a variable. It assumes the sboo project in a folder next to the (current) sbooScripts folder (`"../sboo"` in `baseScript/fakeLib.R`). The script `baseScripts/initTestWorld.R` 1) initiates a empty "World" or landscape with state^1^s; 2) reads data for states from csv files in the data older. A copy from the initTestWorld.R script is below: 

```{r initiate, echo=TRUE, message=FALSE, warning=TRUE}

#This script initialise a standard test (global) environment
#We'll need tidyverse
library(tidyverse)

#script to initialize test environment faking a future 'library(sboo)'
source("baseScripts/fakeLib.R")

#The csv files in the folder data have (collectively) a specific (database-like) structure and contains data only
NewstateModule <- ClassicNanoWorld$new(MlikeFile = "data", Substance = "nAg_10nm")

#with this data we create an instance of the central "SBcore" object (sboo uses the R6 package for its OO part).
World <- SBcore$new(NewstateModule)

#for convenience some functions refer to excel files in the "classic" SB layout
ClassicClass <- ClassicNanoProcess$new(TheCore = World, filename = "data/20210331 SimpleBox4nano_rev006.xlsx")
#apply and replace current kaas :
World$UpdateKaas(ClassicClass)

```

# Input variables

To start and test the Algorithm we can check input from the data read in World using:

```{r read in required variables}
# read in variables from World

data1 <-  World$fetchData("RAINrate")
data2 <- World$fetchData("FRACtwet")
data <- merge(data1,data2)
data
```

## A variable - in the terminology of sboo - is defined by a function. This function is usually simple one, using only scaler parameters. For example 
```{r ProcesDefiningF}
Rad.cw <- function (RAINrate, FRACtwet) {
  # RAINrate.wet is rainrate during wet episodes
  RAINrate.wet <- RAINrate/FRACtwet # RAINrate is yearly average in m/s (input DATA in mm/yr)

  # Rad.cw is returned 
  ((0.7*(60*60*1000*RAINrate.wet)^0.25)/2)/1000 # Radius in Meter, RAINrate.wet in m/s]
}
```

To create the variable the function name (a string, i.e. char[]) is parameter and the object becomes part of the "World"
```{r Radius Cloudwater}
sbooVar <- World$NewCalcVariable("Rad.cw")
sbooVar
```
# test 
This looks complicated, but you'll probably only need a fraction; when testing only the execute() method.
Simple comparing with data from ClassicClass

```{r}

sbooVar$execute()

ClassicClass$Excelgrep("Rad.cw")

```

Additionally another test canbe done data from xlsx version of SimpleBox4nano and the above calculated output

```{r}


# location of xlsx file of SimpleBox (can be left at default)
sb4n.loc <- paste0("data/",list.files("data/")[grep("SimpleBox", list.files("data/"))])

#read out one variable from xlsx version of SimpleBox
# from Regional scale

SB4N_name_R <- "Rad.cwR"
Rad.cwR_xlsx <- as.numeric(openxlsx::read.xlsx(sb4n.loc,colNames=FALSE, namedRegion =SB4N_name_R))

# select only regional variable from calculations
Rad.cwR_calc <- sbooVar$execute()[sbooVar$execute()$Scale=="Regional","Rad.cw"]

# perfor test if they are equal
if(Rad.cwR_calc == Rad.cwR_xlsx) { print("test PASSED, they are equal") } else { print("test FAILED they are not equal, maybe equalish?")}

SB4N_name_R <- "RAINrate.R"
RAINrate.R_xlsx <- as.numeric(openxlsx::read.xlsx(sb4n.loc,colNames=FALSE, namedRegion =SB4N_name_R))
RAINrate.R_R <- data[data$Scale=="Regional","RAINrate"]


```

The test for this example failed due to the small number of decimals being stored in the csv data (currently).
The xlsx rainrate is `r RAINrate.R_xlsx`. The rainrate as read in through R is `r RAINrate.R_R`.

Overall the function is correctly ported, but data needs to be improved in future data/input module.

1.  Link to .md page were state is explained.
