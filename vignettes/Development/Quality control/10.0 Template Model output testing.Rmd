---
title: "Model output"
author: "Joris Quik, Jaap Slootweg, ..."
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
## impossible to generalise? projectRoot <- paste(getwd(), "..", sep = "/")
projectRoot <- paste(getwd(), "..", "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

SimpleBox 4.0 produces two sorts of output; a steady-state or "level
III" output, and the quasi-dynamic or "level IV" output. The
steady-state output is developed when the conditions (loadings and
environmental conditions) remain constant in time for a sufficiently
long period. The mass flows and concentrations are constant in time, as
the sum of the mass balance equation terms is equal to zero for all
boxes, and the n steady-state concentrations can be solved from the n
linear mass balance equations. This steady-state solution is obtained by
means of a matrix inversion routine. The mass flows and concentrations
that characterise this steady state are given in output tables. The
quasi-dynamic output is developed when, after a change in conditions
(loadings or environmental conditions), the mass flows and
concentrations develop toward a new steady state, according to the mass
balance equations. This computation is made by numerical integration of
the set of mass balance equations from time zero, with all
concentrations at zero, to infinite time with all concentrations
constant at steady state. The standard procedure is to compute the
steady-state solution first and carry out the dynamic response
computation afterwards, as an option.

# Initialize

This vignettes demonstrates the mechanism behind SBoo. The model first
needs to be initialized. Before initialisation a substances needs to be
selected, otherwise the "default stubstance" is used. initWorld.R does
just that, and calculates SBvars, flows and k's.

```{r warning=FALSE}
#We need to initialize, by default a molecular substance is selected
Potential_substances <- c("1-aminoanthraquinone", # no class
                          "1-HYDROXYANTHRAQUINONE", # acid
                          "1-Hexadecanamine, N,N-dimethyl-", # base
                          "1-Chloro-2-nitro-propane", # neutral
                          "Sb(III)", # metal
                          "nTiO2_10nm", # nanoparticle (class particle)
                          "microplastic") # microplastic (class particle)
substance <- Potential_substances[2]
source("baseScripts/initWorld_onlyMolec.R")
#source("baseScripts/initworld_onlyMolec.R")

length(unique(World$kaas$process))

ProcessNanoFunctions <- c("k_Advection", "k_Burial",
                         "k_HeteroAgglomeration.a", "k_HeteroAgglomeration.wsd",
                         "k_CWscavenging", "k_Degradation", 
                         "k_DryDeposition", "k_Erosion", "k_Escape", 
                         "k_Leaching", "k_Resuspension", "k_Runoff", "k_Sedimentation", 
                        "k_WetDeposition")

ProcessMolFunctions <- c("k_Adsorption", "k_Advection", "k_Burial",
                          "k_Degradation", "k_Deposition", "k_Desorption",
                          "k_Erosion", "k_Escape", 
                         "k_Leaching", "k_Resuspension", "k_Runoff", "k_Sedimentation", 
                         "k_Volatilisation")


ProcessNanoFunctions[!ProcessNanoFunctions %in% unique(World$kaas$process)]
ProcessMolFunctions[!ProcessMolFunctions %in% unique(World$kaas$process)]

unique(World$kaas$process)
World$kaas
# World$moduleList[["k_Deposition"]]
# World$moduleList[["k_Deposition"]]$execute(debugAt = list())



# World$moduleList[["k_DryDeposition"]]$execute(debugAt = list())
# 
# World$fetchData("rad_species")
# World$fetchData("SettlingVelocity")
# 
# World$NewCalcVariable("SettlingVelocity")
# World$CalcVar("SettlingVelocity")
# 
# World$moduleList[["SettlingVelocity"]]$execute(debugAt = list())
# World$moduleList[["SettlingVelocity"]]$execute()

```

```{r}
#Comparing K's from R model to K's from excel model
library(openxlsx)
library(tidyverse)
#read in K matrix from excel
SBExcelName <- paste0("vignettes/Development/Quality control/SBExcel/SimpleBox4.01_20230824_",substance,".xlsm") #molecular version for now

SBexcel.K <- read.xlsx(SBExcelName,
                  colNames = FALSE,
                  namedRegion = "K")
SBexcel.Names <- read.xlsx(SBExcelName,
                  colNames = FALSE,
                  namedRegion = "box_names")

colnames(SBexcel.K) <- SBexcel.Names

#long format version of Excel K matrix
# colnames(SBexcel.K) <- c("aR",	"w0R",	"w1R",	"w2R",	"sd1R", "sd2R",	"s1R",	"s2R",	"s3R",	"aC",	"w0C",	"w1C",	"w2C",	"sd1C",	"sd2C",	"s1C",	"s2C",	"s3C",	"aM",	"w2M",	"w3M",	"sdM",	"sM",	"aA",	"w2A",	"w3A",	"sdA",	"sA",	"aT",	"w2T",	"w3T",	"sdT",	"sT")
SBexcel.K$to <-  as.character(SBexcel.Names)

SBexcel.K <- pivot_longer(SBexcel.K, cols =  as.character(SBexcel.Names), values_to = "k", names_to = "from")

length(SBexcel.K$k)

#adding "from" and "to" acronyms to the R K matrix
kaas <- tibble(World$kaas)
unique(kaas$fromScale)
unique(kaas$fromSubCompart)

# dit werkt zo helaas niet... 
accronym_map <- c("marinesediment" = "sd2",
                "freshwatersediment" = "sd1",
                "lakesediment" = "sd0", #SB Excel does not have this compartment. To do: can we turn this off (exclude this compartment) for testing?
                "agriculturalsoil" = "s2",
                "naturalsoil" = "s1",
                "othersoil" = "s3",
                "air" = "a",
                "deepocean" = "w3",
                "sea" = "w2",
                "river" = "w1",
                "lake" = "w0")

accronym_map2 <- c("Arctic" = "A",
                   "Moderate" = "M",
                   "Tropic" = "T",
                   "Continental" = "C",
                   "Regional" = "R")

# kaas |> filter(fromScale == "Tropic" & process == "k_Degradation") |> print(n=50)

kaas$from <- paste0(accronym_map[kaas$fromSubCompart], accronym_map2[kaas$fromScale])
kaas$to <- paste0(accronym_map[kaas$toSubCompart], accronym_map2[kaas$toScale])

# Issue that compartments sediment and soil at global scale have sd and s as acronyms instead of sd2
kaas <- kaas |> mutate(from = ifelse((fromScale == "Tropic" | fromScale == "Arctic" | fromScale == "Moderate") & 
  (fromSubCompart == "marinesediment" | fromSubCompart == "naturalsoil"), str_replace_all(from, c("sd2"="sd","s1"="s")), from))

kaas <- kaas |> mutate(to = ifelse((toScale == "Tropic" | toScale == "Arctic" | toScale == "Moderate") & 
  (toSubCompart == "marinesediment" | toSubCompart == "naturalsoil"), str_replace_all(from, c("sd2"="sd","s1"="s")), to))



diagonal_excel <- SBexcel.K[SBexcel.K$from == SBexcel.K$to,] #all the diagonals in excel are negative values -> sums of all the "froms" of that compartment

diagonal <- 
  aggregate(k ~ from, data = kaas, FUN = sum) #R model has k values per process, not per box. For the "diagonal" ("from = to") boxes, this is different than in the excel version. summing all the "froms" here to be able to compare them with excel matrix. This should result in one value for each compartment (scale-subcomp-species combo)
diagonal$process <- "diagonal" # could you add diagonal as a proces, so we see differences in the ggplot below?
# also, could you plot the differences as in ggplot, but then only for diagonal and on x-axis the (to/from) compartments?

ifelse(length(diagonal$k)==length(diagonal_excel$k),
       print("ok"),warning("too many compartment combo's"))

kaas <- merge(kaas, diagonal, by = "from", suffixes = c("", "_summed"))
# SBexcel.K <- merge(SBexcel.K, diagonal_excel, by = "from", suffixes = c("", "_summed"))

mergedkaas <- merge(kaas, SBexcel.K, by = c("from", "to"), suffixes = c("_R", "_Excel"))
str(SBexcel.K)
str(kaas)
str(mergedkaas)

mergedkaas$diff <- ifelse(mergedkaas$from != mergedkaas$to, mergedkaas$k_R - mergedkaas$k_Excel,mergedkaas$k_summed + mergedkaas$k_Excel) #compare R k to Excel K, for rows where "to" == "from" excel is compared to the summed k (see reasoning above). 

plot(mergedkaas$diff)
ggplot(mergedkaas, aes(x = process, y = diff)) +
  geom_boxplot()

```


# Steady state

Emissions need to be defined for the substance selected. This example is
for a molecular compound:

```{r}

emission1 <- data.frame(
  Abbr = c("s1RU", "aRU", "w1RU"),
  Emis = 10e3) # what is the unit?

emission1 <- data.frame(
  Abbr = c("s1RS", "aRS", "w1RS"),
  Emis = 1e3) # what is the unit?


```

```{r testing}
Solvr <- World$NewSolver("SB1Solve")
Solvr <- World$NewSolver("SBsteady")
Solution <- World$Solve(emissions = emission1,
  needdebug = F)

SB.states <- Solvr$states$asDataFrame
SB.states |> count()
SB.k.matrix <- Solvr$SB.k
kaas <- World$kaas

#code from R6SolverModule

         if (any(kaas$k == 0.0)){ #or a very small value?? for solver stability?
          warning(paste(table(kaas$k == 0.0)["TRUE"]), " k values equal to 0; removed for solver")
          kaas <- kaas[kaas$k > 0,]
        }
        # copy, clean states (remove those without any k)
        stateInd <- unique(c(kaas$i, kaas$j))
        #private$States <- SBstates$new(self$myCore$states$asDataFrame[self$myCore$states$matchi(stateInd),])
        # newStates <- self$myCore$states$asDataFrame[self$myCore$states$matchi(stateInd),]
        newStates <- Solvr$states$asDataFrame[Solvr$states$matchi(stateInd),]

        # Why are there here
        Solvr$states$matchi(stateInd)
        nrow(newStates)
       
                if (nrow(newStates) !=  Solvr$states$nStates && exists("verbose") && verbose) {
          warning(paste(Solvr$states$nStates - nrow(newStates),"states without kaas, not in solver"))
        }
        browser()
```

Why are there kaas, but no states for last 4?

Be carefull with all types of cleanup behind the scenes, as this can mask errors and problems with the functions. At least now during development.


```{r}

  
              #remove states without state in columns OR rows => matrix is singular 
        #TODO  dynamic calculation is still possible! if emission is a source??
        stateInd <- unique(kaas$i) 
        stateIndBoth <- stateInd[stateInd %in% unique(kaas$j)]
        if (length(stateInd) != length(stateIndBoth)) {
          warning(paste(length(stateInd) - length(stateIndBoth), " states with no sources OR no sinks"))
          newStates <- newStates[newStates$i %in% stateIndBoth,]
        }
        private$States <- SBstates$new(newStates)
        
        #Reinstate(s) emissions
        if (!is.null(SavedEmissions)){
          OldEmissions <- data.frame(
            Abbr = names(SavedEmissions)[!is.na(names(SavedEmissions))],
            Emis = SavedEmissions[!is.na(names(SavedEmissions))]
          ) 
          self$PrepemisV(OldEmissions)
        }
        
        nrowStates <- private$States$nStates
        k2times <- as.integer(nrowStates*nrowStates)
        SB.K <- matrix(rep.int(0.0, k2times), nrow = nrowStates)
        sumkaas <- aggregate(k ~ i + j, data = kaas, FUN = sum)

        for(SBi in (1:nrow(sumkaas))){
          SB.K[private$States$matchi(sumkaas$j[SBi]),
               private$States$matchi(sumkaas$i[SBi])] <- sumkaas$k[SBi] 
        }
        #Add the from quantities(i) to the to-states by
        #substracting the (negative) factors(i) to the diagonal
        # store the diag (== degradation and other removal processes)
        degrdiag <- diag(SB.K)
        diag(SB.K) <- 0.0 #yes, irt colSums!
        diag(SB.K) <- - degrdiag - colSums(SB.K)


World$fetchData("k_Advection")

World$fetchData("VertDistance")

World$moduleList[["k_Advection"]]$execute()

Solvr$states$nStates
Solvr$states$asDataFrame

Solvr$FromAndTo
str(Solvr)
Solvr$emissions



Solution
str(Solution)
# library(htmlTable)
# World$kaas[World$kaas$fromAbbr == "aRU" & World$kaas$toAbbr == "aRU",]
```


But we want to start with a single state (box): Unbound (Molecular)
Regional air.

Mind the warning... The format of kaas should conform the expected
layout. This particular k has the same from- as to state; It is a sink,
like degradation. We add an emission to the same state, and see what
happens in time.

```{r}

Solvr <- World$NewSolver("SBsolve")
#kaasSquare <- Solvr$PrepKaasM()
Solution <- World$Solve(emissions = data.frame(
  Abbr = c("aRP", "aRU", "w1RU"),
  Emis = 10e6),
  needdebug = F,
  nTIMES = 200 #,
  #EmisAsPulse = T
)

emissions <- ClassicExcel$ExcelEmissions("current.settings")[1,]
World$NewSolver("SBsolve") #
steadSolve <- World$Solve(emissions = emissions)
#World$SolutionAsRelational()
```

## The constants package

Some global constants are imported from this package. For convenience
two functions are availeable, demonstrated below.

```{r}
Concentrations <- function(EqMass, Volume) {
  EqMass / Volume
}
World$NewCalcVariable("Concentrations")
ConcPM <- World$CalcVar("Concentrations")
pivot_wider(ConcPM[, c("SubCompart", "Scale", "Concentrations")],
            values_from = "Concentrations",
            values_fill = NULL,
            names_from = "Scale")
# tidyHtmlTable(
#   x = ConcPM[, c("SubCompart", "Scale", "Concentrations")],
#   value = "Concentrations",
#   header = "Scale",
#   rnames = "SubCompart",
#   #col.header = "#FEFEFE",
#   col.rgroup = c("#FEFEFE", "#F7F7F7")
# )
```

## Mass fluxes

```{r}
MsFlux <- left_join(World$kaas, World$fetchData("EqMass"), 
                    join_by(fromScale == Scale, fromSubCompart == SubCompart, fromSpecies == Species))
MsFlux$mFlux <- MsFlux$k * MsFlux$EqMass
aggregate(mFlux~toAbbr, data = MsFlux, FUN = sum)
```

accuracy? Roundings?? tol doesn't make a difference?!

Happy calculations!
