---
title: "Model output"
author: "Joris Quik, Jaap Slootweg, ..."
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
## impossible to generalise? projectRoot <- paste(getwd(), "..", sep = "/")
projectRoot <- paste(getwd(), "..", "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) #assuming vignette is in a direct subfolder of the project
```

SimpleBox 4.0 produces two sorts of output; a steady-state or "level
III" output, and the quasi-dynamic or "level IV" output. The
steady-state output is developed when the conditions (loadings and
environmental conditions) remain constant in time for a sufficiently
long period. The mass flows and concentrations are constant in time, as
the sum of the mass balance equation terms is equal to zero for all
boxes, and the n steady-state concentrations can be solved from the n
linear mass balance equations. This steady-state solution is obtained by
means of a matrix inversion routine. The mass flows and concentrations
that characterise this steady state are given in output tables. The
quasi-dynamic output is developed when, after a change in conditions
(loadings or environmental conditions), the mass flows and
concentrations develop toward a new steady state, according to the mass
balance equations. This computation is made by numerical integration of
the set of mass balance equations from time zero, with all
concentrations at zero, to infinite time with all concentrations
constant at steady state. The standard procedure is to compute the
steady-state solution first and carry out the dynamic response
computation afterwards, as an option.

# Initialize

This vignettes demonstrates the mechanism behind SBoo. The model first
needs to be initialized. Before initialisation a substances needs to be
selected, otherwise the "default stubstance" is used. initWorld.R does
just that, and calculates SBvars, flows and k's.

[UPDATE 16-2-2024:
- At the moment testing in ongoing for producing a sound K matrix for the below selected 6 substances.
- Certain chemical classes result in several process k's not being calculated:
- onlyMolec script passes proces test for substance: 1, 2, 4, 5

- Deposition not for substance 3,


```{r warning=FALSE}
#We need to initialize, by default a molecular substance is selected
Potential_substances <- c("1-aminoanthraquinone", # no class #67
                          "1-HYDROXYANTHRAQUINONE", # acid
                          "1-Hexadecanamine, N,N-dimethyl-", # base #918
                          "1-Chloro-2-nitro-propane", # neutral
                          "Hg(II)", # metal #1021 SBexcel
                          "nTiO2_10nm", # nanoparticle (class particle)
                          "microplastic") # microplastic (class particle)

substance <- Potential_substances[5]
source("baseScripts/initWorld_onlyMolec.R")

length(unique(World$kaas$process))

ProcessNanoFunctions <- c("k_Advection", "k_Burial",
                         "k_HeteroAgglomeration.a", "k_HeteroAgglomeration.wsd",
                         "k_CWscavenging", "k_Degradation", 
                         "k_DryDeposition", "k_Erosion", "k_Escape", 
                         "k_Leaching", "k_Resuspension", "k_Runoff", "k_Sedimentation", 
                        "k_WetDeposition")

ProcessMolFunctions <- c("k_Adsorption", "k_Advection", "k_Burial",
                          "k_Degradation", "k_Deposition", "k_Desorption",
                          "k_Erosion", "k_Escape", 
                         "k_Leaching", "k_Resuspension", "k_Runoff", "k_Sedimentation", 
                         "k_Volatilisation")

# To test if all processes are calculated for a Particulate substance, the ones missing are shown:
ProcessNanoFunctions[!ProcessNanoFunctions %in% unique(World$kaas$process)]

# To test if all processes are calculated for a Molecular substance, the ones missing are shown:
ProcessMolFunctions[!ProcessMolFunctions %in% unique(World$kaas$process)]

# the processes being calculated:
unique(World$kaas$process)
World$kaas

# The from and to compartments for a process can be seen like this:
World$moduleList[["k_Adsorption"]]$FromAndTo
# The calculation can be initiated and debugged like this:
World$moduleList[["k_Adsorption"]]$execute(debugAt = list(ScaleName = "Regional"))

# if debugging of a missing or NA variable is needed, this can be done like so:
kex = World$NewCalcVariable("Kaers")
kex$execute(debugAt = list())

# for seeing what is known for a certain variable:
World$fetchData("Kaers")


unique(World$kaas$process)
World$moduleList[["k_Deposition"]]
World$moduleList[["k_Deposition"]]$FromAndTo
World$moduleList[["k_Desorption"]]$execute(debugAt = list())

World$fetchData("Ksdcompw")
kex = World$NewCalcVariable("KswDorC")
kex$execute(debugAt = list())
World$fetchData("pKa")
World$fetchData("KswDorC")
World$fetchData("KpCOL")

kex = World$NewCalcVariable("KpCOL")
kex$execute(debugAt = list(Matrix = "water"))

#kscompw issues:
World$fetchData("Kscompw")
kex = World$NewCalcVariable("Kscompw")
kex$execute(debugAt = list(Matrix = "soil"))
World$fetchData("Kp")
kex = World$NewCalcVariable("Kp")
kex$execute(debugAt = list(Matrix = "soil"))

World$fetchData("Pvap25")
World$fetchData("Kacompw")
kex = World$NewCalcVariable("Kacompw")
kex$execute(debugAt = list(ChemClass = "metal"))

World$fetchData("FRorig")
World$fetchData("FRACa")
kex = World$NewCalcVariable("FRACa")
kex$execute(debugAt = list(Matrix = "soil"))

World$fetchData("Kp")

World$fetchData("QSARtable")
World$fetchData("ChemClasClass")

World$fetchData("Kscompw")
kex = World$NewCalcVariable("Kscompw")
kex$execute(debugAt = list(Matrix = "soil"))

# World$moduleList[["k_Leaching"]]$execute(debugAt = list())
# 
# World$fetchData("rad_species")
# World$fetchData("SettlingVelocity")
# 
# World$NewCalcVariable("SettlingVelocity")
# World$CalcVar("SettlingVelocity")
# 
# World$moduleList[["SettlingVelocity"]]$execute(debugAt = list())
# World$moduleList[["SettlingVelocity"]]$execute()

```

```{r}
#Comparing K's from R model to K's from excel model
#library(openxlsx)

#read in K matrix from excel
SBExcelName <- paste0("data/SimpleBox4.01_20230824_",substance,".xlsm") #molecular version for now
SBexcel.K <- read.xlsx(SBExcelName,
                  colNames = FALSE,
                  namedRegion = "K")

#long format version of Excel K matrix
colnames(SBexcel.K) <- c("aR",	"w0R",	"w1R",	"w2R",	"sd1R", "sd2R",	"s1R",	"s2R",	"s3R",	"aC",	"w0C",	"w1C",	"w2C",	"sd1C",	"sd2C",	"s1C",	"s2C",	"s3C",	"aM",	"w2M",	"w3M",	"sdM",	"sM",	"aA",	"w2A",	"w3A",	"sdA",	"sA",	"aT",	"w2T",	"w3T",	"sdT",	"sT")
SBexcel.K$to <- c("aR",	"w0R",	"w1R",	"w2R",	"sd1R", "sd2R",	"s1R",	"s2R",	"s3R",	"aC",	"w0C",	"w1C",	"w2C",	"sd1C",	"sd2C",	"s1C",	"s2C",	"s3C",	"aM",	"w2M",	"w3M",	"sdM",	"sM",	"aA",	"w2A",	"w3A",	"sdA",	"sA",	"aT",	"w2T",	"w3T",	"sdT",	"sT")
SBexcel.K <- pivot_longer(SBexcel.K, cols = c("aR",	"w0R",	"w1R",	"w2R",	"sd1R", "sd2R",	"s1R",	"s2R",	"s3R",	"aC",	"w0C",	"w1C",	"w2C",	"sd1C",	"sd2C",	"s1C",	"s2C",	"s3C",	"aM",	"w2M",	"w3M",	"sdM",	"sM",	"aA",	"w2A",	"w3A",	"sdA",	"sA",	"aT",	"w2T",	"w3T",	"sdT",	"sT"), values_to = "k", names_to = "from")

#adding "from" and "to" acronyms to the R K matrix
kaas <- World$kaas
unique(kaas$fromScale)
unique(kaas$fromSubCompart)

accronym_map <- c("marinesediment" = "sd2",
                "freshwatersediment" = "sd1",
                "lakesediment" = "sd3", #SB Excel does not have this compartment. To do: can we turn this off (exclude this compartment) for testing?
                "agriculturalsoil" = "s2",
                "naturalsoil" = "s1",
                "othersoil" = "s3",
                "air" = "a",
                "deepocean" = "w3",
                "sea" = "w2",
                "lake" = "w1",
                "river" = "w0")

accronym_map2 <- c("Arctic" = "A",
                   "Moderate" = "M",
                   "Tropic" = "T",
                   "Continental" = "C",
                   "Regional" = "R")

kaas$from <- paste0(accronym_map[kaas$fromSubCompart], accronym_map2[kaas$fromScale])
kaas$to <- paste0(accronym_map[kaas$toSubCompart], accronym_map2[kaas$toScale])

diagonal_excel <- SBexcel.K[SBexcel.K$from == SBexcel.K$to,] #all the diagonals in excel are negative values -> sums of all the "froms" of that compartment

diagonal <- aggregate(k ~ from, data = kaas, FUN = sum) #R model has k values per process, not per box. For the "diagonal" ("from = to") boxes, this is different than in the excel version. summing all the "froms" here to be able to compare them with excel matrix
kaas <- merge(kaas, diagonal, by = "from", suffixes = c("", "_summed"))

mergedkaas <- merge(kaas, SBexcel.K, by = c("from", "to"), suffixes = c("_R", "_Excel"))

mergedkaas$diff <- ifelse(mergedkaas$from != mergedkaas$to, mergedkaas$k_R - mergedkaas$k_Excel,mergedkaas$k_summed + mergedkaas$k_Excel) #compare R k to Excel K, for rows where "to" == "from" excel is compared to the summed k (see reasoning above). 

plot(mergedkaas$diff)
ggplot(mergedkaas, aes(x = process, y = diff)) +
  geom_boxplot()

```


# Steady state

Emissions need to be defined for the substance selected. This example is
for a molecular compound:

```{r}

emission1 <- data.frame(
  Abbr = c("s1RU", "aRU", "w1RU"),
  Emis = 10e3) # what is the unit?

emission1 <- data.frame(
  Abbr = c("s1RS", "aRS", "w1RS"),
  Emis = 1e3) # what is the unit?


```

```{r testing}
Solvr <- World$NewSolver("SB1Solve")
Solvr <- World$NewSolver("SBsteady")
Solution <- World$Solve(emissions = emission1,
  needdebug = F)

SB.states <- Solvr$states$asDataFrame
SB.states |> count()
SB.k.matrix <- Solvr$SB.k
kaas <- World$kaas

#code from R6SolverModule

         if (any(kaas$k == 0.0)){ #or a very small value?? for solver stability?
          warning(paste(table(kaas$k == 0.0)["TRUE"]), " k values equal to 0; removed for solver")
          kaas <- kaas[kaas$k > 0,]
        }
        # copy, clean states (remove those without any k)
        stateInd <- unique(c(kaas$i, kaas$j))
        #private$States <- SBstates$new(self$myCore$states$asDataFrame[self$myCore$states$matchi(stateInd),])
        # newStates <- self$myCore$states$asDataFrame[self$myCore$states$matchi(stateInd),]
        newStates <- Solvr$states$asDataFrame[Solvr$states$matchi(stateInd),]

        # Why are there here
        Solvr$states$matchi(stateInd)
        nrow(newStates)
       
                if (nrow(newStates) !=  Solvr$states$nStates && exists("verbose") && verbose) {
          warning(paste(Solvr$states$nStates - nrow(newStates),"states without kaas, not in solver"))
        }
        browser()
```

Why are there kaas, but no states for last 4?

Be carefull with all types of cleanup behind the scenes, as this can mask errors and problems with the functions. At least now during development.


```{r}

  
              #remove states without state in columns OR rows => matrix is singular 
        #TODO  dynamic calculation is still possible! if emission is a source??
        stateInd <- unique(kaas$i) 
        stateIndBoth <- stateInd[stateInd %in% unique(kaas$j)]
        if (length(stateInd) != length(stateIndBoth)) {
          warning(paste(length(stateInd) - length(stateIndBoth), " states with no sources OR no sinks"))
          newStates <- newStates[newStates$i %in% stateIndBoth,]
        }
        private$States <- SBstates$new(newStates)
        
        #Reinstate(s) emissions
        if (!is.null(SavedEmissions)){
          OldEmissions <- data.frame(
            Abbr = names(SavedEmissions)[!is.na(names(SavedEmissions))],
            Emis = SavedEmissions[!is.na(names(SavedEmissions))]
          ) 
          self$PrepemisV(OldEmissions)
        }
        
        nrowStates <- private$States$nStates
        k2times <- as.integer(nrowStates*nrowStates)
        SB.K <- matrix(rep.int(0.0, k2times), nrow = nrowStates)
        sumkaas <- aggregate(k ~ i + j, data = kaas, FUN = sum)

        for(SBi in (1:nrow(sumkaas))){
          SB.K[private$States$matchi(sumkaas$j[SBi]),
               private$States$matchi(sumkaas$i[SBi])] <- sumkaas$k[SBi] 
        }
        #Add the from quantities(i) to the to-states by
        #substracting the (negative) factors(i) to the diagonal
        # store the diag (== degradation and other removal processes)
        degrdiag <- diag(SB.K)
        diag(SB.K) <- 0.0 #yes, irt colSums!
        diag(SB.K) <- - degrdiag - colSums(SB.K)


World$fetchData("k_Advection")

World$fetchData("VertDistance")

World$moduleList[["k_Advection"]]$execute()

Solvr$states$nStates
Solvr$states$asDataFrame

Solvr$FromAndTo
str(Solvr)
Solvr$emissions



Solution
str(Solution)
# library(htmlTable)
# World$kaas[World$kaas$fromAbbr == "aRU" & World$kaas$toAbbr == "aRU",]
```


But we want to start with a single state (box): Unbound (Molecular)
Regional air.

Mind the warning... The format of kaas should conform the expected
layout. This particular k has the same from- as to state; It is a sink,
like degradation. We add an emission to the same state, and see what
happens in time.

```{r}

Solvr <- World$NewSolver("SBsolve")
#kaasSquare <- Solvr$PrepKaasM()
Solution <- World$Solve(emissions = data.frame(
  Abbr = c("aRP", "aRU", "w1RU"),
  Emis = 10e6),
  needdebug = F,
  nTIMES = 200 #,
  #EmisAsPulse = T
)

emissions <- ClassicExcel$ExcelEmissions("current.settings")[1,]
World$NewSolver("SBsolve") #
steadSolve <- World$Solve(emissions = emissions)
#World$SolutionAsRelational()
```

## The constants package

Some global constants are imported from this package. For convenience
two functions are availeable, demonstrated below.

```{r}
Concentrations <- function(EqMass, Volume) {
  EqMass / Volume
}
World$NewCalcVariable("Concentrations")
ConcPM <- World$CalcVar("Concentrations")
pivot_wider(ConcPM[, c("SubCompart", "Scale", "Concentrations")],
            values_from = "Concentrations",
            values_fill = NULL,
            names_from = "Scale")
# tidyHtmlTable(
#   x = ConcPM[, c("SubCompart", "Scale", "Concentrations")],
#   value = "Concentrations",
#   header = "Scale",
#   rnames = "SubCompart",
#   #col.header = "#FEFEFE",
#   col.rgroup = c("#FEFEFE", "#F7F7F7")
# )
```

## Mass fluxes

```{r}
MsFlux <- left_join(World$kaas, World$fetchData("EqMass"), 
                    join_by(fromScale == Scale, fromSubCompart == SubCompart, fromSpecies == Species))
MsFlux$mFlux <- MsFlux$k * MsFlux$EqMass
aggregate(mFlux~toAbbr, data = MsFlux, FUN = sum)
```

accuracy? Roundings?? tol doesn't make a difference?!

Happy calculations!
