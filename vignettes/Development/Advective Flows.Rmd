---
title: "Air Flow"
author: "JS"
date: "3/31/2022"
output: github_document
editor_options: 
  chunk_output_type: console
---

## A flow in SBOO

This vignette demonstrates the implementation of a "flow". A flow in the context of SB is the massflow of a matrix (air, water, ) from one box to another, where either the subcompartment or scale is different. This flow is calculated for a process, usually and by default "Advection". The airflow is a nice example how to model and use flows.

## Initialise 

We use a special script to initialize SB, creating two objects, the first we will use is named "World". When we print it, we see the methods (functions) and properties (active binding), divided in a public and a private part.

```{r}
source("baseScripts/initTestWorld.R")
# World
```

## World

The object named World is of the class SBcore, which is the most imported in use. Other objects are often made part of SBCore objects. Before calculating we need some variables. If you want to read more about variables (in the context of SBOO) read the vignette "FirstVars"

```{r}
SBvars <- c("AreaLand",
            "AreaSea",
            "Area",
            "Volume"
            )

for (x in SBvars) {
  World$NewCalcVariable(x)
  World$CalcVar(x)
}
```

We calculate AirFlow in two steps. The first is the application of a simple model of air circulation depending on windspeed; The mean residence time in the region is according the fTAU function. The AirFlow function calculates the amount that would enter/leave the region namely the volume divided by the residence time. Notice that fTAU is a normal function, but AirFlow will be used as a variable defining function. After the call to World\$CalcVar("AirFlow") this property is stored in the data within World.

```{r}
# fTAU
AirFlow
World$NewCalcVariable("AirFlow")
World$CalcVar("AirFlow")
```

## But

this would not guarantee that the amount from one scale to the next would equal the amount flowing the opposite way! To honour the mass balance we give priority to the amount calculated for the smallest volume to calculate the actual flows. For nested scales we need to know how the nesting is. This brings a new challange; we need to know properties of the scale the flow is going to, or possibly the scale ehere it is going to. Because of the nesting, we need to know even properties of scale not directly related to the to- or the from scale! In this example we see use of the "to.", the "from." and the "all." preposition. The to- and from scaleName are atomic (a single string) but the "all." prepositions provides a full table of the variable and its dimensions (in this case only scale). If you want to see what is really going on in the function calls you can use the debug parameter. This debugging is not availeable for (the whole) World; use the (silent) return value of World\$New[Variable\|Flow\|Process] ! After the r section below you can enter at the console prompt of R-studio: AdvAir\$execute(debugAt = list(toScale = "Continental"))

```{r}
x_Advection_Air
AdvAir <- World$NewFlow("x_Advection_Air")
#AdvAir$execute(debugAt = list(toScale = "Continental"))
World$CalcVar("x_Advection_Air")
```

Does it add up?

```{r}
AirFlows <- World$fetchData("x_Advection_Air")
ToFlow <- aggregate(flow~toScale, data = AirFlows, FUN = sum)
FromFlow <- aggregate(flow~fromScale, data = AirFlows, FUN = sum)
merge(FromFlow, ToFlow, by.x = "fromScale", by.y = "toScale")
```
