---
title: "Parallel solver use"
author: "Anne Hids"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

This script shows how to solve probabilistically in steady state and
dynamically in parallel.

```{R Load packages, warning=FALSE, message=FALSE}
source("baseScripts/installRequirements.R")
```

# Solve steady state in parallel

Firstly, initialize the World you want to use for your calculations. In
this case that is initWorld_onlyPlastics.R.

```{R init World SS, warning=FALSE, message=FALSE}
source('baseScripts/initWorld_onlyPlastics.R')
```

Define the variables needed for solving steady state probabilistically.
These are the same variables needed for the regular steady state
probabilistic solver:

-   emissions: the emissions dataframe

-   var_box_df: a dataframe with the example variables

-   var_invFun: the functions created from the var_box_df in a list.

**The emissions dataframe must be named 'emissions' for the
parallel calculations to work!**

```{R Define variables SS, warning=FALSE, message=FALSE}
var_box_df <- readxl::read_xlsx("data/Examples/Example_uncertain_variables.xlsx", sheet = "Variable_data")

var_invFun <- World$makeInvFuns(var_box_df)

load("data/Examples/example_uncertain_data.RData")

emissions <- example_data |>
  select(To_Compartment, `2023`, RUN) |>
  rename("Emis" = `2023`) |>
  mutate(Abbr = case_when(
    To_Compartment == "Agricultural soil (micro)" ~ "s2RS",
    To_Compartment == "Residential soil (micro)" ~ "s3RS",
    To_Compartment == "Surface water (micro)" ~ "w1RS"
  )) |>
  mutate(Emis = (Emis*1000)/(365.25*24*3600)) |> # Convert t/y to kg/s
  select(-To_Compartment)
```

Now call World$Solve() as below: with emissions = NULL and ParallelPreparation = T. 
In addition the variable functions, the variable dataframe and the number of runs
Have to be given to the solve function. 

Running the solve function in this manner will do two things:
- pull and scale the LHS samples for variables, and then save the matrix in the SBooScripts/data folder
- Save a copy of the current World object, for use in parallel solving.

```{R Save LHS matrix and World using WorldSolve() SS, warning=FALSE, message=FALSE}
# Call the steady state solver
World$NewSolver("SteadyStateSolver")
World$Solve(emissions = NULL, var_box_df = var_box_df, var_invFun = var_invFun, nRUNs = length(unique(emissions$RUN)), ParallelPreparation = T)
```

Specify how many cores you have available for calculations. If you are calculating
on your own computer, use a maximum of all available cores - 1.

Also specify the maximum number of runs per batch.

```{R Specify number of cores SS, warning=FALSE, message=FALSE}
nCores <- 3
max_runs_per_batch <- 3
```

Now the script for solving steady state in parallel can be called. After this 
script finishes running the outcomes are in the list named 'Solution'. You can 
save the outcome as an RData file.

```{R Solve SS in parallel, warning=FALSE, message=FALSE}
source("baseScripts/ParallelSteadyState.R")

# Save the outcome
saveRDS(Solution, "data/Solution.RData")
```

# Solve dynamically in parallel

Firstly, initialize the World you want to use for your calculations. In
this case that is initWorld_onlyPlastics.R.

```{R init World Dyn, warning=FALSE, message=FALSE}
source('baseScripts/initWorld_onlyPlastics.R')
```

Define the variables needed for solving steady state probabilistically.
These are the same variables needed for the regular steady state
probabilistic solver:

-   emissions: the emissions dataframe

-   var_box_df: a dataframe with the example variables

-   var_invFun: the functions created from the var_box_df in a list

-   tmax: the end time for running the solver, in seconds

-   nTIMES: the number of calculation time steps.

**The names given to each of the variables must be the ones given in
the list above ('emissions', 'tmax', 'nTIMES') for the
parallel calculations to work!**

```{R Define variables Dyn, warning=FALSE, message=FALSE}
var_box_df <- readxl::read_xlsx("data/Examples/Example_uncertain_variables.xlsx", sheet = "Variable_data")

var_invFun <- World$makeInvFuns(var_box_df)

load("data/Examples/example_uncertain_data.RData")

emissions <- example_data |>
  select(To_Compartment, `2020`, `2021`,`2022`, `2023`, RUN) |>
  pivot_longer(!c(To_Compartment, RUN), names_to = "year", values_to = "Emis") |>
  mutate(Abbr = case_when(
    To_Compartment == "Agricultural soil (micro)" ~ "s2RS",
    To_Compartment == "Residential soil (micro)" ~ "s3RS",
    To_Compartment == "Surface water (micro)" ~ "w1RS"
  )) |>
  select(-To_Compartment) |>
  mutate(Time = ((as.numeric(year)-2019)*365.25*24*3600)) |>
  mutate(Emis = (Emis*1000)/(365.25*24*3600)) |> # Convert t/year to kg/s
  select(-year)

tmax <- 365.25*24*60*60*length(unique(emissions$Time))

nTIMES <- length(seq(0, tmax, length.out = 10))
```

Now call World$Solve() as below: with emissions = NULL and ParallelPreparation = T. 
In addition the variable functions, the variable dataframe and the number of runs
Have to be given to the solve function. 

Running the solve function in this manner will do two things:
- pull and scale the LHS samples for variables, and then save the matrix in the SBooScripts/data folder
- Save a copy of the current World object, for use in parallel solving.

```{R Save LHS matrix and World using WorldSolve() Dyn, warning=FALSE, message=FALSE}
# Call the dynamic solver
World$NewSolver("DynamicSolver")
World$Solve(emissions = NULL, var_box_df = var_box_df, var_invFun = var_invFun, nRUNs = 20, ParallelPreparation = T)
```

Specify how many cores you have available for calculations. If you are calculating
on your own computer, use a maximum of all available cores - 1.

Also specify the maximum number of runs per batch.

```{R Specify number of cores Dyn, warning=FALSE, message=FALSE}
nCores <- 3
max_runs_per_batch <- 3
```

Now the script for solving steady state in parallel can be called. After this 
script finishes running the outcomes are in the list named 'Solution'. You can 
save the outcome as an RData file.

```{R Solve Dyn in parallel, warning=FALSE, message=FALSE}
source("baseScripts/ParallelDynamic.R")

# Save the outcome
saveRDS(Solution, "data/Solution.RData")
```
