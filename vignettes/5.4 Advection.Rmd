---
title: "5.4 Advection"
author: "Jaap Slootweg, Joris Quik, Valerie de Rijk"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

## 5.4 Advection

Here the implementation of the advective flows of air and water in SBoo
are illustrated. An advective flow in the context of SB is the massflow
of a matrix (air, water ) from one box to another, where either the
subcompartment or scale is different.

```{r initialize, include=FALSE}
source("baseScripts/initWorld_onlyMolec.R")
```

For calculating the rate constants for advection there is data needed on
several parameters such as wind speeds, discharges, residence times etc.
All the different fluxes or flows of air or water are calculated after
which these flows can be converted to rate constants. All default data
are stored in csv files and the values can be read using
'World\$fetchData("...")'. They can be adjusted using
'World\$mutateVars(...)' and then the World can be updated for
downstream variable updates using: 'WorldUpdateDirty(unique(...))'.
Examples can be found in the case studies.

Here we illustrate all the flow processes defined.

### Air flow

The air flow rate is calculated in two steps.

First the AirFlow is calculated based on the residence time of air:

```{r}
World$fetchData("Volume")
World$fetchData("Area")
World$fetchData("WINDspeed")
World$fetchData("SubCompartName")

f_TAU

AirFlow

World$fetchData("AirFlow")

```

The mean residence time in the region is calculated according the f_TAU
function.

The AirFlow function calculates the amount that would enter/leave the
region; namely the volume divided by the residence time. Notice that
f_TAU is a normal function, but AirFlow will be used as a variable
defining function. This provides the overall airflow within a
compartment which affects the flow from this compartment or scale to the
next. Currently air only flows between scales.

Second, from the AirFlow the flows are actually connected to each other.

```{r}
x_Advection_Air
# AdvAir <- World$NewFlow("x_Advection_Air")
# AdvAir$execute(debugAt = list(toScale = "Continental"))
World$CalcVar("x_Advection_Air")
```

To ensure mass balance in the model the amount from one scale to the
next would need to be equal to the amount flowing the opposite way! To
honor the mass balance we give priority to the amount calculated for the
smallest volume to calculate the actual flows. This means that for
nested scales we need to know their 'place' in the world. This brings a
new challenge; we need to know properties of the scale the flow is going
to, or possibly the scale where it is coming from. Because of the
nesting, we need to know even properties of scale not directly related
to the to- or from- the scale! To accommodate this use of the "to.", the
"from." and the "all." preposition is made available. The to- and from
scaleName are atomic (a single string) but the "all." prepositions
provides a full table of the variable and its dimensions (in this case
only across Scales). If you want to see what is really going on in the
function calls you can use the debug parameter.

This provides the air flows. To test if they add up and give the same
amount flowing to and from each scale we do the following calculation:

```{r}
AirFlows <- World$fetchData("x_Advection_Air")
ToFlow <- aggregate(flow~toScale, data = AirFlows, FUN = sum)
FromFlow <- aggregate(flow~fromScale, data = AirFlows, FUN = sum)
merge(FromFlow, ToFlow, by.x = "fromScale", by.y = "toScale", suffixes = c("_from", "_to")) 
merge(FromFlow, ToFlow, by.x = "fromScale", by.y = "toScale", suffixes = c("_from", "_to")) |> mutate(from_to_Diff = flow_from-flow_to)

```

### Water flow

All flows dealing with advective processes are denoted by x_files in
SBOO. Different dimensions are relevant for computing the water flows:
subcompartments and scale. This relates to water flowing from lake,
through the river compartment to the sea, after which the sea flows
between scales. This is defined in the following x_flow. The order of
calculation matters (for regional and continental scale function x 1-5)
!

#### *1. Continental to Regional Fresh water (w1)*

x_ContRiver2Reg calculates based on the fraction of discharge of fresh
water to the regional scale the amount of fresh water flowing from
continental to regional scale. This function also depends on the
different contributors to continental discharge. These are: Runoff and
RainOnFreshwater for both freshwater compartments (w0 and w1). In the
default scenario where the regional scale coincides with a watershed
this is 0, but when e.g. country boundaries are taken this becomes
relevant as there could be inflow of freshwater across the border. The
main driving variable is 'dischargeFRAC' which indicates the fraction of
freshwater outflow at continental scale flowing to regional scale (set
for Cont. Scale).

```{r}
x_ContRiver2Reg
World$fetchData("dischargeFRAC")

World$fetchData("Runoff")
World$fetchData("RainOnFreshwater")
World$fetchData("ScaleName")
World$fetchData("SubCompartName")

World$fetchData("LakeFracRiver") # needs to be cleanup after basing on area fraction.

World$fetchData("x_ContRiver2Reg")
```

#### *2. x_RiverDischarge*

```{r}
x_RiverDischarge

World$fetchData("Runoff")

World$fetchData("RainOnFreshwater")

World$fetchData("dischargeFRAC")
World$fetchData("x_ContRiver2Reg")
World$fetchData("ScaleName")
World$fetchData("x_RiverDischarge")
# World$CalcVar("x_RiverDischarge")
```

#### *3. x_LakeOutflow*

The Lake compartment (w0) is an upstream compartment within a Scale that
has outflow to fresh water (w1). The outflow is dependent on the
fraction runoff going to lake and the direct Rain on lake fresh water.

```{r}
x_LakeOut

World$fetchData("RainOnFreshwater")
World$fetchData("Runoff")
World$fetchData("FracROWatComp")
World$fetchData("ScaleName")
World$fetchData("x_LakeOut")

# flow = World$NewCalcVariable("x_LakeOut")
# flow$execute()
# flow$execute(debugAt = list(assembly=NA))

```

#### *4. x_ContSea2Reg*

x_ContSea2Reg calculates the flow from the sea at continental scale to
the sea at regional scale. It is now the default approach which is a
flow 9 times higher than the river discharge at regional scale. This
coincides with the regional sea mixing being 10 times the river
discharge into the sea.
<!--# A change could be implemented here based on a residence time of sea at regional scale as the river flow is not always relevant for the contribution to this flow, e.g. depending on the type of sea and location one is trying to model. -->

```{r}
x_ContSea2Reg
World$fetchData("LakeFracRiver")
World$fetchData("x_RiverDischarge")
World$fetchData("x_ContSea2Reg")
# 
# flow4 <- World$NewFlow("x_ContSea2Reg")
# 
# flow4$FromAndTo
# flow4$execute()
# World$CalcVar("x_ContSea2Reg")
# World$fetchData("x_ContSea2Reg")
# World$fetchDataUnits("x_ContSea2Reg")

```

#### *5. x_RegSea2Cont*

x_RegSea2Cont is the sea water flow from regional to continental scale.
It is assumed to be 10 times the discharge flow from the river.

```{r}

World$fetchData("LakeFracRiver")
World$fetchData("x_RiverDischarge")
World$fetchData("x_RegSea2Cont")

# flow5 <- World$NewFlow("x_RegSea2Cont")
# 
# flow5$FromAndTo
# flow5$execute()
# World$CalcVar("x_RegSea2Cont")

```

*6. x_ToModerateWater*

Advection of continental sea, Tropic and Arctic sea compartments to sea
and deepocean at Moderate scale.

```{r}

World$fetchData("Volume")
World$fetchData("TAUsea")
World$fetchData("x_RegSea2Cont")
World$fetchData("x_ToModerateWater")

# flow6 <- World$NewFlow("x_ToModerateWater")
# 
# flow6$FromAndTo
# flow6$execute()
# World$CalcVar("x_ToModerateWater")

```

#### Water flow from Moderate Scale

*7. x_FromModerate2TropWater*

Separated in different flows based on the to Scale

```{r}

World$fetchData("Volume")
World$fetchData("TAUsea")
World$fetchData("OceanCurrent")
World$fetchData("x_RegSea2Cont")
World$fetchData("ScaleName")
World$fetchData("x_FromModerate2TropWater")

# flow <- World$NewFlow("x_FromModerate2TropWater")
# flow$execute(debugAt = list())
# flow$FromAndTo
# flow$execute()
# World$CalcVar("x_FromModerate2TropWater")

```

*8. x_FromModerate2ArctWater*

```{r}
World$fetchData("OceanCurrent")
World$fetchData("ScaleName")
World$fetchData("x_FromModerate2ArctWater")

# flow <- World$NewFlow("x_FromModerate2ArctWater")
# # flow$execute(debugAt = list())
# flow$FromAndTo
# flow$execute()
# World$CalcVar("x_FromModerate2ArctWater")
```

*9. x_FromModerate2ContWater*

```{r}
# required data:
World$fetchData("Volume")
World$fetchData("TAUsea")
World$fetchData("OceanCurrent")
World$fetchData("x_RegSea2Cont")
World$fetchData("ScaleName")
World$fetchData("x_FromModerate2ContWater")

# flow <- World$NewFlow("x_FromModerate2ContWater")
# # flow$execute(debugAt = list())
# flow$FromAndTo
# flow$execute()
# World$CalcVar("x_FromModerate2ContWater")

```

*10. x_OceanMixing2Deep*

```{r}
x_OceanMixing2Deep

World$fetchData("Volume")
World$fetchData("TAUsea")
World$fetchData("OceanCurrent")
World$fetchData("SubCompartName")
World$fetchData("x_OceanMixing2Deep")

# flow <- World$NewFlow("x_OceanMixing2Deep")
# 
# flow$FromAndTo
# flow$execute()
# World$CalcVar("x_OceanMixing2Deep")

```

*11. x_OceanMixing2Sea*

```{r}
x_OceanMixing2Sea

World$fetchData("Volume")
World$fetchData("TAUsea")
World$fetchData("OceanCurrent")
World$fetchData("SubCompartName")
World$fetchData("x_OceanMixing2Sea")

# flow <- World$NewFlow("x_OceanMixing2Sea")
# 
# flow$FromAndTo
# flow$execute()
# World$CalcVar("x_OceanMixing2Sea")
```

#### Overview of water flows

Overview of flows included above (excludes surface - deep ocean mixing
and ocean currents at global scales). All to and from water flows should
be equal, e.g. the differences is 0.

```{r testing table}
flows = World$moduleList[["k_Advection"]]$WithFlow

flux2Test <- World$fetchData("Flows")
flux2Test <- flux2Test[flux2Test$FlowName %in% flows & flux2Test$fromSubCompart %in% c("river","sea","lake","deepocean"),]
flux2Test$fromScale <- factor(flux2Test$fromScale, levels = c("Regional", "Continental", "Moderate","Arctic","Tropic")) #force order
flux2Test$toScale <- factor(flux2Test$toScale, levels = c("Regional", "Continental", "Moderate","Arctic","Tropic")) #force order
flux2Test$fromSubCompart <- factor(flux2Test$fromSubCompart, levels = c("lake", "river", "sea","deepocean")) #force order
flux2Test$toSubCompart <- factor(flux2Test$toSubCompart, levels = c("lake", "river", "sea","deepocean")) #force order
f2Torder <- order(flux2Test$fromScale, flux2Test$fromSubCompart, flux2Test$toScale, flux2Test$toSubCompart)

flux2Test$fcolumns <- do.call(paste, c(flux2Test[c("fromScale", "fromSubCompart")], sep="."))
flux2Test$frows <- do.call(paste, c(flux2Test[c("toScale", "toSubCompart")], sep = "."))
#flux2Test$flux = 10e9 * flux2Test$flux # tune unit 

table1 <- pivot_wider(flux2Test[f2Torder,c("frows","fcolumns","flow")],
            id_cols = frows, names_from = fcolumns, values_from = flow)


toFlows <- data.frame(Compartment = table1$frows,
                      tFlow = rowSums(as.data.frame(table1[,-1],),na.rm = TRUE))
froFlows <- data.frame(Compartment = colnames(table1[,-1]),
                       fFlow = colSums(as.data.frame(table1[,-1],),na.rm = TRUE))

tfFlows <- merge(toFlows,froFlows, all=TRUE) 

if(c(sum(tfFlows$tFlow,na.rm = TRUE)-sum(tfFlows$fFlow)) != 0){
  warning("Water flows are not in balance!")
  }

print(table1, n=40)

```

### Advection rate constant

This process is only one step beyond the calculation of the relevant
flows, see the function f_Advection. All flows are by default associated
with this process. "flow" is used as special keyword, there is no SB
variable with the name flow. You can find the values by fetching
"Flows". This also means the script to get the k_Advection is a little
different from other k's. See below:

```{r}
World$fetchData("Flows")
 k_Advection
# Don't create a new process like: World$FromDataAndTo("k_Advection")
# find the existing one like this:
testProc <- World$moduleList[["k_Advection"]]
# FromDataAndTo is from and to from the data, ultimately the property is used
# which can derived from the flows for Advection
FAT <- testProc$FromAndTo
# the data frmae to be calculated:
left_join(rename(FAT, "Scale" = "fromScale", "SubCompart" = "fromSubCompart"), World$fetchData("Volume"))
#for testing use:
testProc$execute()

```
