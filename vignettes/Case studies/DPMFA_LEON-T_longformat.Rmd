---
title: "DPMFA LEON-T"
author: "Anne Hids, Joris Quik"
date: "`r Sys.Date()`"
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::knit_meta()
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
projectRoot <- paste(getwd(), "..", "..", sep = "/")
knitr::opts_knit$set(root.dir = projectRoot) 
```

# *Initializing World and Substance*

Depending on the substance you want to analyze, a selection needs to be
made from the three different"worlds" : Molecular, Particulate and
Plastics. Here, we initialize the world for plastics.

```{r Initialize World}
library(lhs)
library(readxl)
library(viridis)
library(trapezoid)

source("baseScripts/initWorld_onlyPlastics.R")

World$substance <- "microplastic"
```

# Load the DPMFA data and make a nested emission dataframe

```{r Load DPMFA data}

source_of_interest <- c("Tyre wear", "Paint") # NA for all
# Select PMFA data for 2019
PMFA_year <- 2019

# for local case study folder:
abspath <- "vignettes/Case Studies/CaseData/Baseline_PMFA_EU.RData"

load(abspath)

# Check if the loaded data is DPMFA or PMFA data
if(exists("DPMFA_stocks")) {
  MFAtype <- "DPMFA"
} else {
  MFAtype <- "PMFA"
}

if(MFAtype == "PMFA"){
  
  # unnest tibbles to very long format (memory intensive)
  DPMFA_sink <- 
    DPMFA_sink |> unnest(Mass_Polymer_kt, keep_empty = TRUE) |> 
    pivot_longer(cols=-c(Type, Scale, Source, Polymer, To_Compartment, Material_Type, iD_source, RUN),
                 names_to = "Year",
                 values_to = "Mass_Polymer_kt") 
  
  # sink_source_names <- unique(DPMFA_sink$Source)
  # print(sink_source_names)
  
  if (all(!is.na(source_of_interest))) {
    # Check if all the elements of source_of_interest are present in DPMFA_sink$Source
    if (!all(source_of_interest %in% unique(DPMFA_sink$Source))) {
      print("Selected source(s) not in dataframe")
    } else {
      selected_sources <- source_of_interest
    }
  } else if (all(is.na(source_of_interest))) {
    # If all elements are NA, return all unique sources
    selected_sources <- unique(DPMFA_sink$Source)
  }
  
  # Calculate kg/s from kt/y 
  DPMFA_sink_micro <- DPMFA_sink |>
    filter(Source %in% selected_sources) |> # remove sources not of interest
    mutate(Mass_Polymer_kg_s = Mass_Polymer_kt*1000000/(365.25*24*3600),
           .keep = c("unused")) |>
    filter(Material_Type == "micro") |> 
    mutate(Scale = case_when(
      str_detect(Scale, "EU") ~ "C",
      str_detect(Scale, "NL") ~ "R",
    ))
  
  # Assign SB compartments to DPMFA compartments
  DPMFA_sink_micro <- 
    DPMFA_sink_micro |>
    filter(Year == PMFA_year) |> # select for PMFA only 1 year
    select(Source,Polymer, To_Compartment, Scale, Material_Type, Year, RUN, Mass_Polymer_kg_s) |>
    # mutate(Scale = SBscale) |>
    mutate(Compartment = case_when(
      str_detect(To_Compartment, "soil") ~ "s",
      str_detect(To_Compartment, "water") ~ "w",
      str_detect(To_Compartment, "air") ~ "a"
    )) |>
    mutate(Subcompartment = case_when(
      str_detect(To_Compartment, "Agricultural") ~ "2",
      str_detect(To_Compartment, "Natural") ~ "1",
      str_detect(To_Compartment, "Sub-surface") ~ "4", # subsurface out of scope, potential for future subcompartment
      str_detect(To_Compartment, "Road side") ~ "3", # for now other soil, but potential for future subcompartment
      str_detect(To_Compartment, "Residential") ~ "3",
      str_detect(To_Compartment, "Sea") ~ "2",
      str_detect(To_Compartment, "Surface") ~ "1",
      str_detect(To_Compartment, "Outdoor") ~ ""
    )) |>
    mutate(Species = case_when(
      Source == "Tyre wear" ~ "P",
      .default = "S")) |>
    mutate(Abbr = paste0(Compartment, Subcompartment, Scale, Species)) |> # Abbr is the key for SimpleBox compartments
    mutate(Subcompartment = paste0(Compartment, Subcompartment)) |> 
    group_by(Source, Polymer, Year, Material_Type, Abbr, RUN, Subcompartment, Scale, Species) |>
    summarise(Mass_Polymer_kg_s = sum(Mass_Polymer_kg_s)) |>
    ungroup() |>
    rename(value = Mass_Polymer_kg_s) #|> why do we need it to be value?
  #    select(Source, Abbr, Year, Polymer,  value, RUN)
  
} else (print("DPMFA not implemented yet"))





```

```{r Make a df with the emissions}
TESTING = T
if(TESTING==TRUE) DPMFA_sink_micro <- DPMFA_sink_micro |> filter(RUN<11)

# Filter out emission subcompartments for which SimpleBox does not have a compartment (yet)
DPMFA_sink_micro <-
  DPMFA_sink_micro |> filter(Subcompartment %in% World$fetchData("AbbrC")$AbbrC)

if(MFAtype == "PMFA"){
  DPMFA_sink_micro <- DPMFA_sink_micro |>
    nest(Emis = c(RUN, value))
} else if(MFAtype == "DPMFA"){ # TODO when using DPMFA filtering should not occur for 1 year. All years should be used.
  emis_df_dyn <- DPMFA_sink_micro |>
    group_by(Abbr, Year) |>
    rename(Timed = Year) |>
    mutate(Timed = as.double(Timed)*(365.25*24*3600)) |>
    nest(Emis = c(RUN, value))
  
  ymin <- min(emis_df_dyn$Year)
  ymax <- max(emis_df_dyn$Year)
}
```

```{r Functions for distributions}
# Define triangular distribution function
triangular <- function(u, a, b, c) {               # u = samples, a = min, b = max, c = peak
  ifelse(u < (c-a)/(b-a),
         a + sqrt(u * (b-a) * (c-a)),
         b - sqrt((1-u) * (b-a) * (b-c)))
}

# Define uniform distribution function
uniform <- function(u, a, b) {                     # u = samples, a = min, b = max
  transformed_samples <- a + (b - a) * u
  return(transformed_samples)
}

# Define power law distribution function
power_law <- function(u, a, b, c){                 # u = samples, a = min, b = max, c = alpha
  
  # Ensure that samples are within [0, 1]
  samples <- pmin(pmax(u, 0), 1)
  
  # Transform samples to the power-law distribution
  scaled_samples <- a * ((b / a) ^ samples) ^ (1 / (1 - c))
  
  return(scaled_samples)
}

trapezoidal <- function(u, a, b, c, d) {
  # Ensure u is in the range [0, 1]
  u <- pmin(pmax(u, 0), 1)  # Clip u to [0, 1]
  
  # Total width of the trapezoid
  width_total <- d - a
  base1 <- b - a    # Width of the left base
  base2 <- d - c    # Width of the right base
  
  # Calculate the CDF segments
  CDF_left <- base1 / width_total         # Area under the left triangle
  CDF_flat <- 1 - base2 / width_total     # Area under the flat top
  
  result <- ifelse(u < (base1 / width_total), 
                   a + sqrt(u * (base1) * width_total),  # Left triangle
                   ifelse(u <= (CDF_flat + base1 / width_total), 
                          b + (u - base1 / width_total) * (d - b),  # Flat top
                          d - sqrt((1 - u) * (base2) * width_total)  # Right triangle
                   )
  )
  
  return(result)
}

```

# Create dataset with uncertain variables

## Prepare excel data

```{r Prepare excel data}
# Path to excel file with distribution values
#path_dist <- "N:/Documents/Simplebox/Microplastic_variables_v2.xlsx"
path_parameters_file <- "vignettes/Case studies/CaseData/Microplastic_variables_v1.xlsx"

Material_Parameters <- read_excel(path_parameters_file, sheet = "Polymer_data") |> 
  
  # change um to nm unit coversion
  mutate(across(c(a, b, c, d), as.numeric)) |>
  mutate(across(c(a, b, c, d), ~ case_when(
    str_detect(Unit, "um") ~ . * 1000,
    TRUE ~ .
  ))) |>
  mutate(Unit = case_when(
    str_detect(Unit, "um") ~ "nm",
    TRUE ~ Unit
  ))

materials <- unique(Material_Parameters$Polymer)
materials <- unique(DPMFA_sink_micro$Polymer) # materials in selected sources



# TODO: get these from SB objects and not set in text input:
# water <- c("lake", "sea", "deepocean", "river")
# soil <- c("naturalsoil", "agriculturalsoil", "othersoil")
# sediment <- c("marinesediment", "freshwatersediment", "lakesediment")
# soil_sediment <- c(soil, sediment)
# air <- c("air", "cloudwater")
# all_SC <- c(water, soil, sediment, air)
# species <- c("Large", "Small", "Solid")
# small_large <- c("Small", "Large")
# scales <- c("Arctic", "Tropic", "Moderate", "Regional", "Continental")

# Only the ones with data in xlsx or with emission data are needed no? Why this vector?
# materials <- c("HDPE", "LDPE", "PP", "PS", "PVC", "Acryl", "PA", "PET", "ABS", "EPS", "PC", "PMMA", "PUR", "RUBBER", "OTHER")
explodeF <- function(df, target_col, explode_value, new_values) {
  df %>%
    # Use mutate to create a new column if the target column equals explode_value
    mutate(!!sym(target_col) := ifelse(!!sym(target_col) == explode_value, list(new_values), !!sym(target_col))) %>%
    # Unnest the target column to duplicate rows
    unnest(!!sym(target_col))
}

DefinedVariables <- lapply(unique(Material_Parameters$VarName),World$fetchData)
names(DefinedVariables) = unique(Material_Parameters$VarName)


# how to cope with any. For now this, but materials should be only for material being calculated for.
suppressWarnings({
  Material_Parameters <- explodeF(Material_Parameters, target_col = "Polymer", explode_value = "any", new_values = materials)
})

```


```{r Make sample df}
# Generate the correct number of samples
n_samples <- nrow(DPMFA_sink_micro$Emis[[1]]) # Number of emission runs 

unique_combinations <- DPMFA_sink_micro |>
  distinct(Source, Polymer)


sample_df <- data.frame()

for(i in 1:nrow(unique_combinations)){
  
  source <- unique_combinations$Source[i]
  pol <- unique_combinations$Polymer[i]
  
  input_vars <- 
    Material_Parameters |>
    filter(if_all(c(Distribution, a, b), ~ !is.na(.) )) |> # filter out non defined distributions
    filter(Polymer == pol) |> 
    # Not sure what the 3 lines below do.
    group_by(VarName, Scale, SubCompart, Species, Polymer) |>
    filter(if (n() > 1) MP_source == source | (MP_source == "" & !any(MP_source == source)) else TRUE) |>
    ungroup()
  
  n_vars <- nrow(input_vars)
  
  # Generate LHS
  lhs_samples <- randomLHS(n_samples, n_vars)
  # var_df_names <- c()
  
  # somthing like this should work to get the nested tibble with data of samples
  sample_df_var <-  
    input_vars |> 
    mutate(nvar = c(1:8)) |> 
    rowwise() |> 
    mutate(
      data = 
        case_match(Distribution,
                   "Triangular" ~ list(triangular(lhs_samples[, nvar], a, b, c)),
                   "Uniform" ~  list(uniform(lhs_samples[, nvar], a, b)),
                   "Powerlaw" ~  list( power_law(lhs_samples[, nvar], a, b, c)),
                   "Trapezoidal" ~  list( trapezoidal(lhs_samples[, nvar], a, b, c, d)),
                   .default = NA
        )
    ) 
  
  sample_df_var <- sample_df_var |>
    mutate(Polymer = pol) |>
    mutate(Source = source)
  
  sample_df <- rbind(sample_df, sample_df_var)
}


scales <- union((World$FromDataAndTo()$fromScale),(World$FromDataAndTo()$toScale))
subCompartments <-  union((World$FromDataAndTo()$fromSubCompart),(World$FromDataAndTo()$toSubCompart))
species <- union((World$FromDataAndTo()$fromSpecies),(World$FromDataAndTo()$toSpecies))

sample_df <- 
  sample_df %>% 
    separate_rows(Species, sep = "_") |> 
    separate_rows(SubCompart, sep = "_") |>
    mutate( Scale = str_replace_all(Scale, "any",
                                    paste(scales,collapse="__"))) |> 
    separate_rows(Species, sep = "__") |> 
    mutate( SubCompart = str_replace_all(SubCompart, "Water",
                                         paste(c("lake", "sea", "deepocean", "river"),
                                               collapse = "__"))) |> 
    separate_rows(SubCompart, sep = "__") |> 
        mutate( SubCompart = str_replace_all(SubCompart, "Soil",
                                         paste(subCompartments |> str_subset(c("soil")),
                                               collapse = "__"))) |> 
    separate_rows(SubCompart, sep = "__") |> 
            mutate( SubCompart = str_replace_all(SubCompart, "Sediment",
                                         paste(subCompartments |> str_subset(c("sediment")),
                                               collapse = "__"))) |> 
    separate_rows(SubCompart, sep = "__") |> 
       mutate( Species = str_replace_all(Species, "any",
                                    paste(species,collapse="__"))) |> 
    separate_rows(Species, sep = "__") |> 
           mutate( SubCompart = str_replace_all(SubCompart, "any",
                                    paste(subCompartments,collapse="__"))) |> 
    separate_rows(SubCompart, sep = "__")

```

```{r Make some figures to show the values chosen from the distributions}

sample_df_Tyre_wear_RUBBER <- sample_df |>
  filter(Source == "Tyre wear")

alpha_water <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "alpha") |>
  filter(SubCompart == "sea") |>
  filter(Species == "Small") 

alpha_water <- alpha_water$data[[1]]

# Make some figures of the distributions
ggplot(alpha_water, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of attachment efficiency for water compartments",
       x = "Alpha") + scale_x_continuous(trans='log10') +
  theme_classic()

alpha_soil <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "alpha") |>
  filter(SubCompart == "naturalsoil") |>
  filter(Species == "Small") 

alpha_soil <- alpha_soil$data[[1]]

# Make some figures of the distributions
ggplot(alpha_soil, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of attachment efficiency for soil and sediment compartments",
       x = "Alpha")+ scale_x_continuous(trans='log10') +
  theme_classic()

rads <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "RadS")

rads <- rads$data[[1]]

ggplot(rads, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of particle radius",
       x = "Radius (nm)")+
  theme_classic()

rhos <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "RhoS")

rhos <- rhos$data[[1]]

ggplot(rhos, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of density",
       x = "Density (g/m^3)")+
  theme_classic()

kdeg_soil <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "kdeg") |>
  filter(SubCompart == "naturalsoil") |>
  filter(Species == "Small") 

kdeg_soil <- kdeg_soil$data[[1]]

# Make some figures of the distributions
ggplot(kdeg_soil, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of degradation rate constant for soil and sediment compartments",
       x = "Degradation rate constant (s-1)")+
  theme_classic()

kdeg_water <- sample_df_Tyre_wear_RUBBER |>
  filter(varName == "kdeg") |>
  filter(SubCompart == "sea") |>
  filter(Species == "Small") 

kdeg_water <- kdeg_water$data[[1]]

# Make some figures of the distributions
ggplot(kdeg_water, mapping = aes(x = value)) +
  geom_histogram(bins=50, color="#00AFBB", fill=NA) +
  labs(title = "Distribution of degradation rate constant for water compartments",
       x = "Degradation rate constant (s-1)")+
  theme_classic()
```

# Solve the matrix and calculate concentrations

Solve the matrix depending on the type of input emissions given (PMFA =
Steady state, DPMFA = dynamic)

```{r Solve steady state}
start_time <- Sys.time()


solutions <- data.frame()
concentrations <- data.frame()

if(type == "PMFA"){ 
  World$NewSolver("UncertainSolver")
  
  for(i in 1:nrow(unique_combinations)){
    source <- unique_combinations$Source[i]
    pol <- unique_combinations$Polymer[i]
    
    emis_source <- DPMFA_sink_micro |>
      filter(Source == source) |>
      filter(Polymer == pol) #|>
    #select(Abbr, Emis)
    
    sample_source <- sample_df |>
      filter(Source == source) |>
      filter(Polymer == pol) |>
      select(-c(Source, Polymer))
    
    solved <- World$Solve((emis_source), needdebug = F, sample_source)
    solution <- solved$SteadyStateMass |>
      mutate(Polymer = pol) |>
      mutate(Source = source)
    
    if (nrow(solutions) == 0) {
      solutions <- solution  # Initialize with the structure of `solution`
    } else {
      solutions <- rbind(solutions, solution)
    }
    
    # Get the concentrations
    conc <- World$GetConcentration() |>
      mutate(Polymer = pol) |>
      mutate(Source = source)
    
    print(colnames(conc))
    
    if (nrow(concentrations) == 0) {
      concentrations <- conc  # Initialize with the structure of `solution`
    } else {
      concentrations <- rbind(concentrations, conc)
    }
  }
  
} else if(type == "DPMFA"){
  World$NewSolver("UncertainDynamicSolver")
  
  for(pol in polymers){
    emis_df_name <- paste0("emis_dyn_", pol)
    sample_df_name <- pasteo("sample_df_", pol)
    
    solved <- World$Solve(World$Solve(get(pol)), sample_df, tmax = tmax, needdebug = F)
    assign(paste0("solved_dyn_", pol), solved)
    
    # Get the concentrations
    conc_df_name <- paste0("solution_", pol)
    conc <- World$GetConcentration()
    
    assign(conc_df_name, conc)
  }
}
end_time <- Sys.time()

elapsed_time <- end_time - start_time

print(paste0("Elapsed time is ", elapsed_time))

# 10000 runs will take 4 hours and 10 minutes per polymer-source combination.
```

# Prep data and make plots

```{r}

# Create a plot theme
plot_theme <-  theme(
  axis.title.x = element_text(size = 14),    
  axis.title.y = element_text(size = 14),    
  axis.text.x = element_text(size = 12, angle = 45, hjust = 1),     
  axis.text.y = element_text(size = 12),
  title = element_text(size=20),
  panel.background = element_rect(fill = "white"),  # White background
  panel.grid.major = element_line(color = "lightgrey", size = 0.5),  # Major grid lines in light grey
  panel.grid.minor = element_line(color = "lightgrey", size = 0.25)
)

# Plot the data for each polymer separately, for all selected compartments (different plots depending on PMFA or DPMFA)
if(type == "PMFA"){
  for(mat in polymers){
    solution_name <- paste0("solution_", mat)
    df_name <- paste0("solved_ss_", mat)
    
    Solution <- get(solution_name) |>
      mutate(RUN = as.integer(RUN)) |>
      # mutate(EqMass = as.double(EqMass)) |>
      mutate(Concentration = as.double(Concentration)) 
    
    solved <- get(df_name)
    
    subt <- paste0(mat, ", ", y)
    
    # Prepare data for plots
    Input_Variables <- 
      solved$Input_Variables |> unnest(data) 
    Input_Emission <- 
      solved$Input_Emission |> unnest(Emis) 
    
    Plot_data <- 
      Input_Variables |> 
      pivot_wider(names_from = c(varName,Scale,SubCompart,Unit), values_from = value) |> 
      full_join(Solution) |>
      full_join(Input_Emission, by = c("Abbr", "RUN"))
    
    # Aggregate plot data for all species
    Plot_data_agg <- Plot_data |>
      group_by(Scale, SubCompart, RUN, Unit.x, Units_per_SubCompart) |>
      summarise(EqMass = sum(EqMass), Concentration = sum(Concentration))
    
    scales <- unique(Plot_data_agg$Scale)
    
    # Make plots for each scale, one with mass and one with concentrations
    for (scale in scales) {
      df <- Plot_data_agg |>
        filter(Scale == scale) |>
        mutate(concname = paste0(SubCompart, " (", Units_per_SubCompart, ")"))
      
      # Filter out the compartments without mass
      masscomps <- df |>
        filter(RUN == 1) |>
        filter(EqMass != 0)
      
      masscomps <- masscomps$SubCompart
      
      df <- df |>
        filter(SubCompart %in% masscomps)
      
      # Mass plot
      mass_p <- ggplot(df, mapping = aes(x = SubCompart, y = EqMass, fill = SubCompart)) +  
        geom_violin() + 
        labs(title = paste0("Masses at ", scale, " scale"),
             subtitle = subt,
             x = "Compartment",
             y = "Mass (kg)") +
        plot_theme +
        scale_y_continuous(trans = 'log10') +
        scale_fill_viridis_d() + 
        # Customize the legend for this plot as well
        theme(axis.text.x = element_blank(),  # Remove x-axis labels
              legend.position = "bottom") +   # Move legend to the bottom
        guides(fill = guide_legend(title = NULL))  # Remove legend title
      
      print(mass_p)
      
      ggsave(paste0("vignettes/Case Studies/CaseData/Mass_plot_", scale, ".png"), plot=mass_p)
      
      # Concentration plot
      conc_p <- ggplot(df, mapping = aes(x = concname, y = Concentration, fill = concname)) +  
        geom_violin() +
        labs(title = paste0("Concentrations at ", scale, " scale"),
             subtitle = subt,
             x = "Compartment",
             y = "Concentration") +
        plot_theme +
        scale_y_continuous(trans = 'log10') +
        scale_fill_viridis_d() +
        theme(axis.text.x = element_blank(),  # Remove x-axis labels
              legend.position = "bottom") +   # Move legend to the bottom
        guides(fill = guide_legend(title = NULL))  # Remove legend title
      
      print(conc_p)
      
      ggsave(paste0("vignettes/Case Studies/CaseData/Concentration_plot_", scale, ".png"), plot=conc_p)
    }
  }
  
} else if(type == "DPMFA"){        
  
  # TO DO: Make plots for DPMFA output
  
}

```
